"""
$(TYPEDEF)

Stores all data that is static throughout iteration of the interior-point method.
Is supposed to be generated by corresponding constructor.

# Fields
$(TYPEDFIELDS)
"""
mutable struct StaticData  
    "PDE parameter"
    p::Float64
    "Domain dimension"
    d::Int8
    "Image dimension, i.e. number of components"
    qdim::Int64
    "Number of nodes in domain mesh"
    n::Int64
    "Number of elements in domain mesh"
    m::Int64

    "Set of actually calculated nodes"
    calculation_nodes::Set{Int64}
    "Number of calculated nodes"
    nCalc::Int64
    "Number of calculated FEM coefficients"
    lengthu::Int64

    "System vector for convex optimization problem"
    c::AbstractVector{Float64}
    "Upper bound for auxilliary variable"
    R::Float64

    "Vector of element weights"
    omega::AbstractVector{Float64}
    "Discrete derivative matrix"
    D::AbstractDict{Tuple{Int64,Int64},SparseMatrixCSC{Float64,Int64}}
    "Prolonged boundary"
    g::AbstractVector{Float64}
    "Discrete derivative of the prolonged boundary condition, i.e. Dg"
    b::AbstractDict{Tuple{Int64,Int64},AbstractVector{Float64}}

    "Constant for barrier self-concordance order"
    sigma::Int64
    "Constant factor for barrier terms"
    alpha::Float64
    "Algorithm constant given by Nesterov as 1/9"
    beta::Float64
    "Algorithm constant given by Nesterov as 5/36"
    gamma::Float64
    "Inverse tolerance used for main path-following termination"
    tolInv::Float64
    "Accuracy to tolerance factor"
    tolFactor::Float64
    "Maximal number of iterations in path-following schemes"
    maxIter::Int64
    "Initial stepsize for long and adaptive path-following"
    kappa::Float64
    "Ranges of slow steps for update of kappa in adaptive path-following"
    kappa_updates::Array{Int64}
    "Powers in the update that is applied to kappa in the relevant ranges"
    kappa_powers::Array{Float64}
    "Maximal number of iterations for backtracking in long and adaptive path-following"
    maxIterationsBacktracking::Int64
    "Decrement factor for backtracking in long and adaptive path-following"
    decrementFactorBacktracking::Float64
    
    "Function pointer on solving routine"
    solveLS::Function
    "Funciton pointer on factorization routine"
    factorize::Function
    "Function pointer on preconditioner"
    computePreconditioner::Function
end

"""
$(TYPEDSIGNATURES)

Constructor for a StaticData object.
In particular computes boundary prolongation if required and its derviative,
upper and lower bounds on the auxiliary variable as well as the system vector. 
"""
function StaticData(
    p::Float64,
    mesh::Mesh,
    dirichlet_nodes::Set{Int64},
    fixed_nodes::Union{Set{Int64}, Missing},
    neumann_elements::Union{Set{Int64}, Missing}, 
    f::Union{AbstractVector{Float64}, Missing},
    g::AbstractVector{Float64},
    h::Union{AbstractVector{Float64}, Missing},
    boundary_prolongation::Union{AbstractVector{Float64}, Missing},
    qdim::Int64,
    eps::Float64,
    maxIter::Int64,
    kappa::Float64,
    kappa_updates::Array{Int64},
    kappa_powers::Array{Float64},
    maxIterationsBacktracking::Int64,
    decrementFactorBacktracking::Float64,
    solver::LinearSolver,
    preconditioner::Preconditioner,
    useHarmonicProlongation::Bool
)
    solveLS, factorize = select_linearsolver(solver)
    computePreconditioner = select_preconditioner(preconditioner)

    sigma = compute_sigma(p)
    nu = mesh.nelems * (sigma + 2)
    alpha = sigma
    beta = 1/9
    gamma = 5/36
    tolFactor = (nu + (((beta + sqrt(nu)) * beta) / (1 - beta))) 
    tolInv =  tolFactor / eps

    if ismissing(boundary_prolongation) && !ismissing(fixed_nodes)
        union!(dirichlet_nodes, fixed_nodes)

        for i in fixed_nodes
            g[(i-1)*qdim+1 : i*qdim] .= 0.0
        end
    end

    calculation_nodes = setdiff(Set(1:mesh.nnodes), dirichlet_nodes)

    has_neumannboundary = !ismissing(neumann_elements)

    has_sourceterm = !ismissing(f) && any(o -> o != 0, f)

    if ismissing(boundary_prolongation)
        if useHarmonicProlongation
            gProl = compute_prolongation_harmonic(
                g,
                mesh,
                has_sourceterm,
                f,
                dirichlet_nodes,
                has_neumannboundary,
                h,
                neumann_elements,
                solveLS,
                computePreconditioner,
                qdim=qdim
            )
        else
            gProl = compute_prolongation_zero(g, mesh, qdim=qdim)
        end
    else
        # check feasiblity
        if length(boundary_prolongation) == mesh.nnodes * qdim
            gProl = copy(boundary_prolongation)
        else
            throw(DimensionMismatch("Provided boundary prolongation does not match mesh."))
        end
    end

    omega = assemble_weightmultivector(mesh, qdim=1, order=1)
    D = assemble_derivativetensor(mesh, qdim=qdim)
    Dmod = assemble_derviativetensor_modified(D, dirichlet_nodes, qdim=qdim)

    b = compute_derivative(D, gProl)

    c = compute_systemvector(
        mesh,
        p,
        omega,
        dirichlet_nodes,
        has_neumannboundary,
        neumann_elements,
        h,
        has_sourceterm,
        f,
        qdim
    )
    R = compute_upperbound(
        mesh,
        p,
        b,
        omega,
        has_neumannboundary,
        neumann_elements,
        h,
        has_sourceterm,
        f,
        qdim
    )

    return StaticData(
        p,
        mesh.d,
        qdim,
        mesh.nnodes,
        mesh.nelems, 
        calculation_nodes,
        length(calculation_nodes),
        length(calculation_nodes)*qdim,
        c,
        R,
        omega,
        Dmod,
        gProl,
        b,
        sigma,
        alpha,
        beta,
        gamma,
        tolInv,
        tolFactor,
        maxIter, 
        kappa,
        kappa_updates,
        kappa_powers,
        maxIterationsBacktracking,
        decrementFactorBacktracking,
        solveLS,
        factorize,
        computePreconditioner
    )
end

"""
$(TYPEDSIGNATURES)
    
Returns factor σ for the barrier function parameter depending on p.
"""
function compute_sigma(p::Float64)
    return p >= 2 ? 1 : 2
end

"""
$(TYPEDSIGNATURES)
    
Computes system vector c for a p-Poisson problem to solve with a barrier method.
"""
function compute_systemvector(
    mesh::Mesh,
    p::Float64,
    omega::AbstractVector{Float64},
    dirichlet_nodes::Set{Int64}, 
    has_neumannboundary::Bool,
    neumann_elements::Union{Set{Int64}, Missing},
    h::Union{AbstractVector{Float64}, Missing},
    has_sourceterm::Bool,
    f::Union{AbstractVector{Float64}, Missing},
    qdim::Int64
)    
    entriesToDrop = Set{Int64}()
    if qdim == 1
        entriesToDrop = dirichlet_nodes
    else
        for node in dirichlet_nodes
            union!(entriesToDrop, qdim*(node-1)+1:qdim*node)
        end
    end

    rhs = zeros(Float64, qdim*(mesh.nnodes-length(dirichlet_nodes)))
    
    if has_sourceterm
        if length(f) == mesh.nnodes*qdim
            M = assemble_massmatrix(
                mesh,
                qdim=qdim,
                order=3
            )
            rhs -= (M * f)[1:end .∉ [entriesToDrop]]
        elseif mod(length(f), mesh.nelems*qdim) == 0
            nPoints = length(f) / (mesh.nelems * qdim)
            quadOrder = quadrature_order(mesh.d, nPoints)
            
            E = assemble_basismatrix(
                mesh,
                qdim=qdim,
                order=quadOrder
            )
            W = Diagonal(
                assemble_weightmultivector(
                    mesh,
                    qdim=qdim,
                    order=quadOrder
                )
            )
            rhs -= (E' * W * f)[1:end .∉ [entriesToDrop]]
        else
            throw(DomainError(f,"Dimension Missmatch"))
        end
    end
    
    if has_neumannboundary
        if length(h) == mesh.nnodes*qdim
            N = assemble_massmatrix_boundary(
                mesh,
                boundaryElements=neumann_elements,
                qdim=qdim,
                order=3
            )
            rhs -= (N * h)[1:end .∉ [entriesToDrop]]
        elseif mod(length(h),mesh.nboundelems*qdim) == 0
            nPoints = div(length(h), mesh.nboundelems * qdim)
            quadOrder = quadrature_order(mesh.d-1, nPoints)

            E = assemble_basismatrix_boundary(
                mesh,
                boundaryElements=neumann_elements,
                qdim=qdim,
                order=quadOrder
            )
            W = Diagonal(
                assemble_weightmultivector_boundary(
                    mesh,
                    qdim=qdim,
                    order=quadOrder
                )
            )
            rhs -= (E' * W * h)[1:end .∉ [entriesToDrop]]
        else
            throw(DomainError(h,"Dimension Missmatch"))
        end
    end

    return [rhs; omega ./ p]
end

"""
$(TYPEDSIGNATURES)

Computes constant upper bound R on the auxiliary variable.
"""
function compute_upperbound(
    mesh::Mesh,
    p::Float64,
    b::AbstractDict{Tuple{Int64,Int64},AbstractVector{Float64}},
    omega::AbstractVector{Float64}, 
    has_neumannboundary::Bool,
    neumann_elements::Union{Set{Int64}, Missing},
    h::Union{AbstractVector{Float64}, Missing}, 
    has_sourceterm::Bool,
    f::Union{AbstractVector{Float64}, Missing},
    qdim::Int64
)
    L::Float64 = stripwidth(mesh)
    
    normg::Float64 = xpnorm(p, b, omega)
    normf::Float64 = 0
    normh::Float64 = 0
    
    if has_sourceterm
        normf = qnorm(p, f, mesh, qdim=qdim, order=5)
    end

    if has_neumannboundary
        normh = qnorm_boundary(
            p,
            h,
            mesh,
            boundaryElements=neumann_elements,
            qdim=qdim,
            order=5
        )
    end

    if p == 1
        R = 2 + 2 * normg / (1 - L * normf)
    else
        q = conjugated_exponent(p)
        R = 2 + 8 * normg^(p) + 4 * L^q * (p / 2)^(1 / (1 - p)) * (p - 1) * normf
    end
    
    return R
end

"""
    compute_prolongation_harmonic(
        g::AbstractVector{Float64},
        mesh::Mesh,
        has_sourceterm::Bool,
        f::AbstractVector{Float64}, 
        dirichlet_nodes::Set{Int64},
        has_neumannboundary::Bool,
        h::AbstractVector{Float64},
        neumann_elements::Set{Int64}, 
        solveLS::Function,
        preconditioner::Function;
        qdim::Int64 = 1
    ) -> AbstractVector{Float64}
    
Returns discrete prolongation of the boundary condition g to the whole domain
as solution of the corresponding linear Laplace problem, i.e. ``p = 2``.

# Mandatory Arguments
- `g::AbstractVector{Float64}`: Discretely evaluated boundary condition.
- `mesh::Mesh`: Mesh of the domain.
- `has_sourceterm::Bool`: Flag for evaluating source term.
- `f::AbstractVector{Float64}`: Source term.
- `dirichlet_nodes::Set{Int64}`: Nodes of the boundary to hold Dirichlet condition.
- `has_neumannboundary::Bool`: Flag for evaluating Neumann boundary.
- `h::AbstractVector{Float64}`: Neumann boundary condition.
- `neumann_elements::Set{Int64}`: Edges of the boundary to hold Neumann condition.
- `solveLS::Function`: Function pointer to solve linear system.
- `preconditioner::Function`: Function pointer to compute preconditioner for linear system.

# Keyword Arguments
- `qdim::Int64 = 1`: Number of components of f, h and g.
"""
function compute_prolongation_harmonic(
    g::AbstractVector{Float64},
    mesh::Mesh,
    has_sourceterm::Bool,
    f::Union{AbstractVector{Float64}, Missing}, 
    dirichlet_nodes::Set{Int64},
    has_neumannboundary::Bool,
    h::Union{AbstractVector{Float64}, Missing},
    neumann_elements::Union{Set{Int64}, Missing}, 
    solveLS::Function,
    preconditioner::Function;
    qdim::Int64 = 1
) :: AbstractVector{Float64}
    rhs = zeros(Float64, qdim*mesh.nnodes)

    if has_sourceterm
        if length(f) == mesh.nnodes*qdim
            M = assemble_massmatrix(
                mesh,
                qdim=qdim,
                order=3
            )
            rhs += M * f
        elseif mod(length(f), mesh.nelems*qdim) == 0
            nPoints = length(f) / (mesh.nelems * qdim)
            quadOrder = quadrature_order(mesh.d, nPoints)

            E = assemble_basismatrix(
                mesh,
                qdim=qdim,
                order=quadOrder
            )
            W = Diagonal(
                assemble_weightmultivector(
                    mesh,
                    qdim=qdim,
                    order=quadOrder
                )
            )
            rhs += E' * W * f
        else
            throw(DomainError(f,"Dimension Missmatch"))
        end
    end
    
    if has_neumannboundary
        if length(h) == mesh.nnodes*qdim
            N = assemble_massmatrix_boundary(
                mesh,
                boundaryElements=neumann_elements,
                qdim=qdim,
                order=3
            )
            rhs += N * h
        elseif mod(length(h), mesh.nboundelems*qdim) == 0
            nPoints = div(length(h), mesh.nboundelems * qdim)
            quadOrder = quadrature_order(mesh.d-1, nPoints)

            E = assemble_basismatrix_boundary(
                mesh,
                boundaryElements=neumann_elements,
                qdim=qdim,
                order=quadOrder
            )
            W = Diagonal(
                assemble_weightmultivector_boundary(
                    mesh,
                    qdim=qdim,
                    order=quadOrder
                )
            )
            rhs += E' * W * h
        else
            throw(DomainError(h,"Dimension Missmatch"))
        end
    end
    
    L = assemble_laplacian(mesh, qdim=qdim)
    assemble_dirichletcondition!(L, dirichlet_nodes, rhs=rhs, bc=g, qdim=qdim)

    return solveLS(L, rhs, preconditioner(L))
end

"""
    compute_prolongation_zero(
        g::AbstractVector{Float64},
        mesh::Mesh;
        qdim::Int64 = 1
    ) -> AbstractVector{Float64}
    
Returns discrete prolongation of g to the whole domain by zero on every node.

Returns discrete prolongation of the boundary condition g to the whole domain
by zero on every node.

# Mandatory Arguments
- `g::AbstractVector{Float64}`: Discretely evaluated boundary condition.
- `mesh::Mesh`: Mesh of the domain.

# Keyword Arguments
- `qdim::Int64 = 1`: Number of components of f, h and g.
"""
function compute_prolongation_zero(
    g::AbstractVector{Float64},
    mesh::Mesh;
    qdim::Int64 = 1
)
    return zeros(Float64, qdim*mesh.nnodes) .+ g
end
