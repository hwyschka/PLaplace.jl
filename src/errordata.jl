"""
$(TYPEDEF)

Structure to hold error values compared to analytical solutions for multiple computations.
Can be used to generate plots.

# Fields
$(TYPEDFIELDS)
"""
mutable struct ErrorData
    "PDE parameters."
    p::Array{Float64,1}
                        
    "Number of gridpoints"
    n::Array{Int64,1}

    "Accuracy"
    eps::Array{Float64,1}
                        
    "Errors"
    errors::Array{Array{Float64,1},1}
end

"""
$(TYPEDSIGNATURES)

Same as previous $(FUNCTIONNAME)(...).
However takes discretized analytical solution and PLaplaceData(@ref) as arguments.

"""
function compute_errors(
    anasol::Array{Float64,1},
    data::PLaplaceData
)
    return compute_errors(
        anasol,
        data.v,
        data.mesh,
        data.neumann_elements,
        data.h,
        data.f,
        data.p,
        data.qdim
    )
end

"""
$(TYPEDSIGNATURES)
    
Clears and writes a header for an error log to the given file. 
"""
function write_error_header(filename::String; guarded::Bool=false)
    fn = occursin(".", filename) ? filename : filename * ".txt"

    if guarded
        check_error_header(fn) && return
    end

    open(fn, "w") do file
        write(file, rpad("p",6), "|")
        write(file, rpad("n",7), "|")
        write(file, rpad("eps",13), "|")
        write(file, rpad("J-error",14), "|")
        write(file, rpad("L1-error",13), "|")
        write(file, rpad("L2-error",13), "|")
        write(file, rpad("LInf-error",13), "\n")
        write(file, repeat("-", 85), "\n")
        write(file, "\$Simulations", "\n")
    end
end

"""
$(TYPEDSIGNATURES)
    
Checks if given file exists and alredy contains an error header. 
"""
function check_error_header(filename::String) :: Bool
    fn = occursin(".", filename) ? filename : filename * ".txt"

    if !isfile(fn)
        return false
    end

    f = open(fn)
    l = readline(f)
    close(f)
    a = split(l, "|")
    
    !contains(a[1],"p") && return false
    !contains(a[2],"n") && return false
    !contains(a[7],"LInf-error") && return false

    return true
end

"""
$(TYPEDSIGNATURES)
    
Writes a given error along other information corresponding to the header to a given file.
"""
function write_error(file_name::String, data::PLaplaceData, error::Array{Float64,1})
    fn = occursin(".", file_name) ? file_name : file_name * ".txt"
    
    sp = @sprintf("%06.3f", data.p)
    sn = @sprintf("%.07i", data.mesh.nnodes)
    ee = @sprintf("%.7e", data.eps)
    oe = @sprintf("%+.7e", error[1])
    e1 = @sprintf("%.7e", error[2])
    e2 = @sprintf("%.7e", error[3])
    ei = @sprintf("%.7e", error[4])

    open(fn, "a") do file
        write(file, sp, " ")
        write(file, sn, " ")
        write(file, ee, " ")
        write(file, oe, " ")
        write(file, e1, " ")
        write(file, e2, " ")
        write(file, ei, "\n")
    end
end

"""
$(TYPEDSIGNATURES)
    
Returns [ErrorData](@ref) when handed an file generated by PLaplace. 
"""
function read_error(fileName::String)
    p = Array{Float64,1}()
    n = Array{Int64,1}()
    eps = Array{Float64,1}()
    errors = Array{Array{Float64,1},1}()
    
    f = open(fileName)

    while (!eof(f) && (l = readline(f)) != "\$Simulations")
    end

    while (!eof(f))
        l = readline(f)
        a = split(l, " ")
        
        push!(p, parse(Float64, a[1]))
        push!(n, parse(Int64, a[2]))
        push!(eps, parse(Float64, a[3]))
        
        e = [
            parse(Float64, a[4]),
            parse(Float64, a[5]),
            parse(Float64, a[6]),
            parse(Float64, a[7])
        ]
        push!(errors, e)      
    end

    close(f)
    
    return ErrorData(p, n, eps, errors)
end

"""
$(TYPEDSIGNATURES)
    
Appends to objects of type [ErrorData](@ref)
by appending all elements of B to the elements in A.
"""
function Base.append!(A::ErrorData, B::ErrorData) 
    append!(A.p, B.p)
    append!(A.n, B.n)
    append!(A.eps, B.eps)
    append!(A.errors, B.errors)
end
