<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm · PLaplace.jl</title><meta name="title" content="Algorithm · PLaplace.jl"/><meta property="og:title" content="Algorithm · PLaplace.jl"/><meta property="twitter:title" content="Algorithm · PLaplace.jl"/><meta name="description" content="Documentation for PLaplace.jl."/><meta property="og:description" content="Documentation for PLaplace.jl."/><meta property="twitter:description" content="Documentation for PLaplace.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PLaplace.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PLaplace.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Algorithm</a><ul class="internal"><li><a class="tocitem" href="#fem-theory"><span>FEM</span></a></li><li><a class="tocitem" href="#convex-problem-theory"><span>Convex Problem</span></a></li><li><a class="tocitem" href="#path-following-theory"><span>Path-Following</span></a></li><li><a class="tocitem" href="#references-theory"><span>References</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/dirichlet-square/">A Dirichlet Problem</a></li><li><a class="tocitem" href="../examples/neumann-square/">A Neumann Problem</a></li><li><a class="tocitem" href="../examples/vector-neumann-cube/">A Vector-Valued Problem</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../lib/public/">Public</a></li><li><a class="tocitem" href="../lib/internal/">Internal</a></li></ul></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hwyschka/PLaplace.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hwyschka/PLaplace.jl/blob/master/docs/src/algorithm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="algorithm-theory"><a class="docs-heading-anchor" href="#algorithm-theory">Algorithm</a><a id="algorithm-theory-1"></a><a class="docs-heading-anchor-permalink" href="#algorithm-theory" title="Permalink"></a></h1><p>The main motivation of this project is to develop an efficient algorithm for vector-valued <em>p</em>-Laplace problems that occur in shape optimization using a <em>p</em>-harmonic approach [<a href="#references-theory">2</a>] such as</p><p class="math-container">\[\underset{v \in W^{1,p}_g(\Omega,\R^d)}
    {\mathrm{arg\;min}}\; \frac{1}{p} \int_{\Omega} \Vert \nabla v \Vert_2^p \;\mathrm{d} x
    - \int_{\Omega} f v \;\mathrm{d} x
    - \int_{\Gamma} h v  \;\mathrm{d}\Gamma\]</p><p>Nevertheless, various kinds of problems can be solved using this package. Assuming sufficient regularity, the given minimization problem is associated with the general Euler-Lagrange-equation</p><p class="math-container">\[\left.\begin{array}{rl}
    -\Delta_p v = f &amp;\text{in } \Omega,\\
    \Vert\nabla v \Vert_2^{p-2} \partial_{\eta} v = h &amp; \text{on } \Gamma,\\
    v = g &amp;\text{on } \partial\Omega\setminus\Gamma
    \end{array}\right\}\]</p><p>for the <em>p</em>-Laplacian <span>$\Delta_p v = \nabla \cdot (\Vert \nabla v \Vert_2^{p-2} \nabla v)$</span>.</p><p>The main intention of this package in julia is not high-performance computing,  but rather creating understandable code and reproducible results. This enables improved opportunities for analysis and quick prototyping.</p><p>The implementation is based on an approach proposed by Loisel [<a href="#references-theory">1</a>] using a reformulation of the problem as a convex optimization problem and then solve it using an interior point method. While originally proposed for pure Dirichlet conditions and just scalar-valued problems, it was extended to general vector-valued problems as well as mixed Dirichlet and Neumann boundary conditions [<a href="#references-theory">4</a>].</p><p>In the following, we give a short introduction into the implementation of the algorithm. We start with some basics and notation for the used finite element library and extension. Then we show the reformulation as a standard convex problem in finite dimension. Finally, we outline the numerical technique for actually solving the problem.</p><h2 id="fem-theory"><a class="docs-heading-anchor" href="#fem-theory">FEM</a><a id="fem-theory-1"></a><a class="docs-heading-anchor-permalink" href="#fem-theory" title="Permalink"></a></h2><p>As the finite element base layer, the package <a href="https://minfem.github.io/MinFEM.jl/stable/"><code>MinFEM.jl</code></a> is used. In particular, linear triangular Lagrange elements with non-negative weights.</p><p>Let a quasi-uniform triangulation with <span>$n$</span> nodes and  <span>$m$</span> elements of a computational domain <span>$\Omega \subset \mathbb{R}^d$</span> be given. Each element <span>$i$</span> is associated with its weight <span>$\omega_i$</span>. In the following, for a function <span>$u: \Omega \rightarrow \mathbb{R}^{d^\prime}$</span>, we also denote by <span>$u \in \mathbb{R}^{nd^\prime}$</span> the finite element coefficient vector corresponding to the global basis functions <span>$\Phi_k$</span>. This vector contains <span>$n$</span> blocks of length <span>$d^\prime$</span> denoting all the components at each node <span>$k$</span>.</p><p>To keep the spirit of the algorithm proposal and use julia&#39;s matrix operations efficiently, we expand the FEM base by introducing discrete derivative matrices for vector-valued functions. Note that this might not be suitable for high performance computing, but results in readable and understandable code,  which is one of the primary intentions of this project. Let</p><p class="math-container">\[D^{(j,r)}_{i,d^\prime (k-1)+r} = \frac{\partial}{\partial x_j} \Phi_k(x^{(i)})\]</p><p>where <span>$x^{(i)}$</span> denotes the midpoint of the element <span>$i$</span>. Multiplication to a coefficient vector results in a vector containing the partial derivatives of the r-th component of a function in direction <span>$x_j$</span> at the midpoints of all elements. Note that there are <span>$d \times d^\prime$</span> partial derivatives for all components and directions at the midpoint of each element. By construction, the vector has full length and all of the other entries are zero. This requires slightly more memory, but allows for easy summation of all the derivatives.</p><h2 id="convex-problem-theory"><a class="docs-heading-anchor" href="#convex-problem-theory">Convex Problem</a><a id="convex-problem-theory-1"></a><a class="docs-heading-anchor-permalink" href="#convex-problem-theory" title="Permalink"></a></h2><p>The first term of the objective functional can be understood as a norm and can be discretized using the previously introduced derivative matrices by</p><p class="math-container">\[\Vert u+g \Vert_{X^p(\Omega)}^p 
    = \int_{\Omega} \Vert \nabla u+g \Vert_2^p \;\mathrm{d} x
    \approx \sum_{i=1}^m \omega_i
        \left(\sum_{j=1}^{d} \sum_{r=1}^{d^\prime} [D^{(j,r)}u + b]_i^2\right)^{\frac{p}{2}}\]</p><p>Note that for functions <span>$v \in W^{1,p}_g(\Omega,\R^d)$</span> it is possible to find a decomposition <span>$v = u + g$</span> such that <span>$u \in W^{1,p}_0(\Omega,\R^d)$</span> and <span>$g \in W^{1,p}_g(\Omega,\R^d)$</span> fixed. This means, we can consider a fixed prolongation of the Dirichlet condition to the full domain, pre-compute <span>$b^{(j,r)} = D^{(j,r)}g$</span> and then just minimize over <span>$u \in W^{1,p}_0(\Omega,\R^d)$</span> with homogeneous Dirichlet conditions in the relevant parts.</p><p>The second and the third term are standard integrals and can be discretized by mass matrices <span>$M$</span> and <span>$\bar{M}$</span> on the domain and the boundary, respectively. Now we can simply obtain a finite version of the problem by reformulating the summation as a scalar product and introduce a slack variable for the non-linear term:  </p><p><em>Minimizing the <em>p</em>-Laplace objective functional over the relevant finite element space</em> <em>is equivalent to the standard convex problem</em></p><p class="math-container">\[\min_{x \in \mathcal{Q}_p} \langle c,x \rangle \text{ with } c = 
    \begin{bmatrix}
        -Mf-\bar{M}h\\ 
        \frac{\omega}{p}
    \end{bmatrix}\]</p><p><em>with a bounded and convex search set given by</em></p><p class="math-container">\[\mathcal{Q}_p = \left\{ 
    (u,s) \in \mathbb{R}^n \times \mathbb{R}^m \, : \,
    s_i \geq \left(\sum_{j=1}^{d} \sum_{r=1}^{d^\prime} 
        [D^{(j,r)}(u+g)]_i^2\right)^{\frac{p}{2}}
    \land \omega_i s_i \leq R \right
\}.\]</p><p>In order to obtain the boundedness of the set with the second condition, an additional constraint</p><p class="math-container">\[\omega_i \Vert \nabla (u+g)\vert_{K_i}\Vert_2^p \leq R\]</p><p>on the local gradients was added. Here, the constant <span>$R$</span> can be chosen large enough to not influence the solution. </p><h2 id="path-following-theory"><a class="docs-heading-anchor" href="#path-following-theory">Path-Following</a><a id="path-following-theory-1"></a><a class="docs-heading-anchor-permalink" href="#path-following-theory" title="Permalink"></a></h2><p>The main part of the implementation is to efficiently solve this convex problem efficiently. Thus, in [<a href="#references-theory">1</a>] is proposed to apply an interior-point method [<a href="#references-theory">4</a>] which is well known in convex optimization. In this method, the problem is solved by approximately following the central path</p><p class="math-container">\[x^*(t) = \underset{x \in \mathcal{Q}_p}{\mathrm{arg\;min}}\;
    t \langle c,x \rangle + F(x)\]</p><p>for <span>$t \rightarrow \infty$</span> and during that staying sufficiently close by satisfying</p><p class="math-container">\[\Vert tc + F^\prime \Vert^*_x \leq \beta.\]</p><p>Here <span>$\beta$</span> is a given parameter and <span>$\Vert \cdot \Vert_x^*$</span> denotes the norm induced by <span>$F$</span> or in particular by its symmetric positive definite Hessian <span>$F^{\prime\prime}$</span> at <span>$x$</span>.</p><p>Thus, in order to apply this method, we need a self-concordant barrier <span>$F$</span> of the  constrained search set as well as its first and second derivatives. We obtain this self-concordant barrier for <span>$\mathcal{Q}_p$</span> by </p><p class="math-container">\[F_p(u,s) = -\sum_{i=1}^m \log{z_i} -\sum_{i=1}^m \log{s_i} -\sum_{i=1}^m \log{\tau_i}\]</p><p>where</p><p class="math-container">\[z_i(u,s) = s^{\frac{2}{p}} - \sum_{j=1}^{d} \sum_{r=1}^{d^\prime} [D^{(j,r)}u + b]_i^2 
    \qquad\text{and}\qquad \tau_i(s) = R - \omega_i s_i.\]</p><p>The derivatives can be found in the literature [<a href="#references-theory">4</a>].</p><p>The general solution procedure then consists of two phases. An auxiliary phase to compute a suitable starting point, and after that a main phase to actually solve the constrained problem up to the given accuracy. Details can be found in [<a href="#references-theory">1,3</a>]. Here, we will only show the key steps for the simplest variant, the short-step path-following.</p><p>For the <strong>auxiliary path-following</strong>, we start with <span>$t_0 = 1$</span>, an arbitrary <span>$x_0 \in \mathcal{Q}_p$</span> and set <span>$G =  -F^\prime(x_0)$</span>. Then we iterate over</p><ol><li><span>$t_{k+1} = t_k - \frac{\gamma}{\Vert G \Vert^*_{x_k}}$</span></li><li><span>$x_{k+1} = x_k - [F^{\prime\prime}(x_k)]^{-1} (t_{k+1} G + F^\prime(x_k))$</span></li></ol><p>until <span>$\Vert F^\prime(x_k) \Vert^*_{x_k} \leq \frac{\sqrt{\beta}}{1+\sqrt{\beta}}$</span>. Doing an additional update step, we then get an <span>$x \in \mathcal{Q}_p$</span> such that  <span>$\Vert F^\prime(x) \Vert^*_{x_k} \leq \beta$</span>, which is a necessary condition for the starting guess in the next phase.</p><p>In the <strong>main path-following</strong>, the iteration is quite similar. However, we start with <span>$t_0 = 0$</span>, pick the final iterate from the previous phase as starting guess and use the system vector <span>$c$</span> instead of the negative initial gradient. The iteration then reads</p><ol><li><span>$t_{k+1} = t_k + \frac{\gamma}{\Vert c \Vert^*_{x_k}}$</span></li><li><span>$x_{k+1} = x_k - [F^{\prime\prime}(x_k)]^{-1} (t_{k+1} c + F^\prime(x_k))$</span></li></ol><p>until t exceeds some given (inverse) tolerance. Note that 2. now corresponds to a classical Newton step for the central path.</p><p>In the implementation, by default, an adaptive stepping with the proposed parameters from [<a href="#references-theory">1</a>] is used. For comparison or numerically challenging problems, it can be beneficial to use the also implemented short- and long-step variants. But be aware that they usually require many more iterations, even if their theoretical worst-case estimate is better. Further, you can adjust all the parameters like step length and its updates by keyword arguments, if necessary.</p><h2 id="references-theory"><a class="docs-heading-anchor" href="#references-theory">References</a><a id="references-theory-1"></a><a class="docs-heading-anchor-permalink" href="#references-theory" title="Permalink"></a></h2><p>[1] S. Loisel. “<a href="https://link.springer.com/article/10.1007/s00211-020-01141-z"><em>Efficient algorithms for solving the p-Laplacian in polynomial time</em></a>”.     Numerische Mathematik. 2020.<br/>[2] P.M. Müller, N. Kühl, M. Siebenborn, K. Deckelnick, M. Hinze and T. Rung.     “<a href="https://link.springer.com/article/10.1007/s00158-021-03030-x"><em>A Novel p-Harmonic Descent Approach Applied to Fluid Dynamic Shape Optimization</em></a>”.     Structural and Multidisciplinary Optimization. 2021.<br/>[3] Y. Nesterov. “<a href="https://link.springer.com/book/10.1007/978-1-4419-8853-9"><em>Introductory lectures on convex optimization</em></a>”.     Applied Optimization. 2004.<br/>[4] H. Wyschka and M. Siebenborn. “<a href="https://link.springer.com/chapter/10.1007/978-3-031-45158-4_9"><em>Towards computing high-order p-harmonic descent     directions and their limits in shape optimization</em></a>”.     In: &quot;Modeling, Simulation and Optimization of Fluid Dynamic Applications&quot;. 2023.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/dirichlet-square/">A Dirichlet Problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Sunday 20 October 2024 10:21">Sunday 20 October 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
