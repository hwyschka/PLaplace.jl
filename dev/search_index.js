var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"MinFEM.jl is available as an registered Julia package and thus the installation  can be done quickly using the package manager. To do so, open the julia REPL, hit the ] key to change into the package mode. The line will now start with something like (@v1.7) pkg> where the numbers denote  you current minor julia version, indicating that you are modifying your full installation. In case there is a package name featured instead,  because you managed dependencies of it before, you need to restart the full REPL. Now you can add the package by typing","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add MinFEM\ntest MinFEM","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If you are interested in modifying the code, you might also clone the GitHub repository  from here to your local machine. Then you can add it as a development package to your Julia installation  by using the package tool in the REPL as before and typing","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"dev C:\\your\\path\\to\\minfem\ntest MinFEM","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"From now on, you can use MinFEM by including it on top of you code file","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using MinFEM","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"In general the workflow starts by creating a mesh of the computational domain. This can either be done by importing a GMSH file or using the internal functions  for creating a unit mesh.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"mesh = import_mesh(\"../meshes/square.msh\")\n\nmesh = unit_square(50)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Subsequently, you can specify physical boundary sets that are used to specify boundary conditions later on. The general syntax returns you a set of the type Boundary, which contains either all physical boundaries specified, or just the selected indices. The indices are either specified in the GMSH file or for the unit meshes given in their respective documentation. Here, 1001 and 1003 select the bottom and left boundary of the unit square. For some applications you might need the all the nodes or elements of a boundary set.  These can be easily extracted and are then given by an unordered set Set{Int64}.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"boundary = select_boundaries(mesh)\nboundary = select_boundaries(mesh, 1001, 1003)\n\nboundaryNodes = extract_nodes(boundary)\nboundaryNodes = extract_elements(boundary)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Next, operators can be assembled.  There are multiple operators available all following the same syntax.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"L = assemble_laplacian(mesh)\nM = assemble_massmatrix(mesh)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"While one could now manually code the solution of the finite element linear system, MinFEM supports the creation of a PDESystem. With this you can set up the linear system as you would in a classical sense and automatically add boundary conditions. Then simply solve the system and the solution will be contained in the object.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"pde = PDESystem(A=L, b=M*ones(mesh.nnodes), bc=zeros(mesh.nnodes), DI=boundaryNodes)\nsolve!(pde)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Finally, you can write the solution to a file. Most commonly, this will be a .vtu file to be read with Paraview for visualization. For the storage of intermediate result it might also be useful to save it as a simple .txt file. This can be read later on and could also be used for visualization with Plots.jl.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"write_to_vtk(pde.state, mesh, \"u\", \"getting_started\")\n\nwrite_to_txt(pde.state, mesh, \"u\", \"getting_started\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"For more detailed tutorial workflows check out the Examples section of this manual. These will include multiple operators as well as a time dependent problem, a non-linear problem and how to handle vector-valued functions.","category":"page"},{"location":"examples/dirichlet-square/#A-Dirichlet-Problem","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"","category":"section"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Let's go through a code for the p-Laplace equation on a unit square","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Omega = (01)^2","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"with boundary","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Gamma = partial Omega","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"and inhomogeneous Dirichlet boundary conditions given by","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"beginaligned\n-Delta_p v = 0 quad textin Omega\nv = x_1^2 quad texton Gamma\nendaligned","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"First, we have to load the package PLaplace:","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"using PLaplace","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Then it is useful to set up a results directory where all the results for one test case are stored. The following functions will do that:","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"output_path::String = \"results/dirichlet-square/\"\nmkpath(output_path)","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"If you do multiple computations, e.g. for different values of p, you might like to compare the runs. Therefore, you can create a statistics file with the corresponding header. Here, the guarded flag means that if the file already exists with a header, the file will not be cleared and rewritten. This is in particular helpful if you have already run a script and want to keep the results. ","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"statistics_file = output_path * \"statistics.txt\"\nwrite_statistics_header(statistics_file, guarded = true)","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Now, we can create the mesh of our computational domain. PLaplace.jl is based on the finite element library MinFEM.jl. Some basic functions are re-exported, so we can simply use","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"mesh = import_mesh(\"../meshes/square.msh\")\ndirichlet_boundary = select_boundaries(mesh)","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"tip: Tip\nYou can also additionally load the MinFEM.jl package to get access to all its features. For example, you could generate a custom mesh of the unit square, e.g., with 30x30 nodes.using PLaplace, MinFEM\n\nmesh = unit_square(30)This can be quite useful later on if you also want to do post-processing and custom projects.","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Then, we specify the boundary condition analytically by","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"g(x) = x[1]^2","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"If no analytical description is available, it is also possible to define a coefficient vector using MinFEM.jl's functionalities, but that would exceed the scope of this tutorial.","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"With the preparations done, we can now run the algorithm by","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"data = solve_plaplace(p, mesh, g, dirichlet_boundary)","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"The returned object data is of type PLaplaceData. In this object, all kinds of relevant information are stored. Please see its documentation in the library for all properties. Here, we want to limit ourselves to its two main use cases.","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"First, we can use it to write an entry to the previously created statistics file","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"write_statistics(statistics_file, data)","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"Second, we can write the result to a .vtk-file","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"write_result_to_vtk(output_path * \"result_p=$p\", data)","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"This file can be used, for example, to visualize the result in Paraview. Some instructions for that can be found in the corresponding section of the MinFEM.jl documentation.","category":"page"},{"location":"examples/dirichlet-square/","page":"A Dirichlet Problem","title":"A Dirichlet Problem","text":"info: Visualization\nHere is an example of what different solutions might look like.(Image: Result)\nSolution of the problem for various p = 1, 2, 3, 5, 8, 15 (left to right).","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"using Markdown, PLaplace\nMarkdown.parse_file(joinpath(pkgdir(PLaplace), \"LICENSE\"))","category":"page"},{"location":"examples/neumann-square/#A-Neumann-Problem","page":"A Neumann Problem","title":"A Neumann Problem","text":"","category":"section"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Let's go through a code for the p-Laplace equation on a unit square","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Omega = (01)^2","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"and a part of the boundary","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Gamma = (0 times 01) cup (01 times 1)","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"with mixed homogeneous Dirichlet and inhomogeneous Neumann boundary conditions given by","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"beginaligned\n-Delta_p v = 0 quad textin Omega\nVert nabla v Vert_2^p-2 fracpartial vpartial eta  \n    = x_2^2 - x_1^2 quad texton Gamma\nv = 0 quad texton partialOmegasetminusGamma\nendaligned","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"The code is quite similar to the Dirichlet Problem, so here, we will mainly focus on the few differences.","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Includes and file creation are identical","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"using PLaplace\n\noutput_path::String = \"results/neumann-square/\"\nmkpath(output_path)\n\nstatistics_file = output_path * \"statistics.txt\"\nwrite_statistics_header(statistics_file, guarded = true)","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"For the mesh with boundary conditions, we will now select two different sets of physical boundaries. One for the Dirichlet part and one for the Neumann part.","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"mesh = import_mesh(\"../meshes/square.msh\")\n\ndirichlet_boundary = select_boundaries(mesh, 1001, 1004)\nneumann_boundary = select_boundaries(mesh, 1002, 1003)","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Here, in particular, the IDs 1001 and 1004 denote the bottom and the right boundary of the square, respectively. 1002 and 1003 are the remaining top and left boundaries. Note that the two boundary sets shall be distinct. If a node is in the Dirichlet boundary, it will be fixed within the algorithm, and the Neumann condition is ignored. For any mesh, you get the physical boundary ideas from the mesh file. The whole procedure of boundary selection is only possible if the boundaries were specified as physical elements in gmsh during the creation of the mesh.","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"The boundary conditions themselves can again be specified analytically using","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"h(x) = x[2]^2 - x[1]^2\ng(x) = 0","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"For actually using the Neumann condition in the algorithm,  the condition itself and the boundary where it shall be applied  have to be provided via keyword arguments.","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"data = solve_plaplace(\n    p,\n    mesh,\n    g,\n    dirichlet_boundary,\n    h = h,\n    neumann_boundary = neumann_boundary\n)","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Note that here, the identifier left of the assignment is the name of the keyword, which is specified in the api. To see a full list of keywords, see the documentation in the library. The identifier on the right is the local name of the variable we created and only the same by (intended) coincidence.","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"Writing output files is no different from the Dirichlet example and is performed with","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"write_statistics(statistics_file, data)\n\nwrite_result_to_vtk(output_path * \"result_p=$p\", data)","category":"page"},{"location":"examples/neumann-square/","page":"A Neumann Problem","title":"A Neumann Problem","text":"info: Visualization\nThe output files can again be used for external post-processing.\nSelected visualized results for comparison are given here.(Image: Result)\nSolution of the problem for various p = 2, 3, 5, 8, 15, 25 (left to right).","category":"page"},{"location":"examples/vector-neumann-cube/#A-Vector-Valued-Problem","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"","category":"section"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"As a vector-valued problem, we will consider a problem in 3 dimensions, where the solution also has 3 components. The general treatment is the same as for the 2-dimensional cases that we have seen before. The dimensions are somewhat hidden in the mesh and the descriptions of source terms and boundary conditions. Thus, we need to use the additional keyword argument qdim to specify the number of components matching those of the function descriptions.","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"The start of the program is similar to before. Just note that in difference to the Neumann example, we now include the cube.msh mesh and there are now 6 physical boundaries corresponding to the 6 faces to select from.","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"using PLaplace\n\noutput_path = \"results/NeumannProblem3DVector/\"\nmkpath(output_path)\n\nstatistics_file = output_path * \"statistics.txt\"\nwrite_statistics_header(statistics_file, guarded = true)\n\nmesh = import_mesh(\"../meshes/cube.msh\")\nneumann_boundary = select_boundaries(mesh, 1003, 1004, 1005)\ndirichlet_boundary = select_boundaries(mesh, 1001, 1002, 1006)","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"In general, the definition of boundary conditions works the same as before. Just that the output is now an array instead of just a scalar. In this example, the description of h corresponds","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"h(x) = Vert x Vert_2  eta","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"where eta denotes the outer normal vector and results in a pulling force.","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"g(x) = [0,0,0]\nfunction h(x)\n    a = sqrt(sum(x.^2))\n    if x[1] > 0\n        if x[2] > 0\n            return a * [0,0,-1]\n        else\n            return a * [0,-1,0]\n        end\n    else\n        return a * [-1,0,0]\n    end\nend","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"Solving the equation and providing output files is now quite similar to the Neumann example. As mentioned before, the only difference is the usage of the keyword argument qdim = 3. This corresponds to the number of components we previously specified for g and h. Note that using this argument is mandatory. Only specifying multiple components in the functions will lead to index-out-of-bounds errors.","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"p::Float64 = 5\n\ndata  = solve_plaplace(\n    p,\n    mesh,\n    g,\n    dirichlet_boundary,\n    h = h,\n    neumann_boundary = neumann_boundary,\n    qdim = 3\n)\n    \nwrite_statistics(statistics_file, data)\nwrite_result_to_vtk(output_path * \"result_p=$p\", data)","category":"page"},{"location":"examples/vector-neumann-cube/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"info: Visualization\nWith the resulting files, you could proceed to visualization. Here, a warped and rotated version of the cube for p=5 is shown.(Image: Result)","category":"page"},{"location":"algorithm/#algorithm-theory","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The main motivation of this project is to develop an efficient algorithm for vector-valued p-Laplace problems that occur in shape optimization using a p-harmonic approach [2] such as","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"undersetv in W^1p_g(OmegaR^d)\n    mathrmargmin frac1p int_Omega Vert nabla v Vert_2^p mathrmd x\n    - int_Omega f v mathrmd x\n    - int_Gamma h v  mathrmdGamma","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Nevertheless, various kinds of problems can be solved using this package. Assuming sufficient regularity, the given minimization problem is associated with the general Euler-Lagrange-equation","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"leftbeginarrayrl\n    -Delta_p v = f textin  Omega\n    Vertnabla v Vert_2^p-2 partial_eta v = h  texton  Gamma\n    v = g texton  partialOmegasetminusGamma\n    endarrayright","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"for the p-Laplacian Delta_p v = nabla cdot (Vert nabla v Vert_2^p-2 nabla v).","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The main intention of this package in julia is not high-performance computing,  but rather creating understandable code and reproducible results. This enables improved opportunities for analysis and quick prototyping.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The implementation is based on an approach proposed by Loisel [1] using a reformulation of the problem as a convex optimization problem and then solve it using an interior point method. While originally proposed for pure Dirichlet conditions and just scalar-valued problems, it was extended to general vector-valued problems as well as mixed Dirichlet and Neumann boundary conditions [4].","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"In the following, we give a short introduction into the implementation of the algorithm. We start with some basics and notation for the used finite element library and extension. Then we show the reformulation as a standard convex problem in finite dimension. Finally, we outline the numerical technique for actually solving the problem.","category":"page"},{"location":"algorithm/#fem-theory","page":"Algorithm","title":"FEM","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"As the finite element base layer, the package MinFEM.jl is used. In particular, linear triangular Lagrange elements with non-negative weights.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Let a quasi-uniform triangulation with n nodes and  m elements of a computational domain Omega subset mathbbR^d be given. Each element i is associated with its weight omega_i. In the following, for a function u Omega rightarrow mathbbR^d^prime, we also denote by u in mathbbR^nd^prime the finite element coefficient vector corresponding to the global basis functions Phi_k. This vector contains n blocks of length d^prime denoting all the components at each node k.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"To keep the spirit of the algorithm proposal and use julia's matrix operations efficiently, we expand the FEM base by introducing discrete derivative matrices for vector-valued functions. Note that this might not be suitable for high performance computing, but results in readable and understandable code,  which is one of the primary intentions of this project. Let","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"D^(jr)_id^prime (k-1)+r = fracpartialpartial x_j Phi_k(x^(i))","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"where x^(i) denotes the midpoint of the element i. Multiplication to a coefficient vector results in a vector containing the partial derivatives of the r-th component of a function in direction x_j at the midpoints of all elements. Note that there are d times d^prime partial derivatives for all components and directions at the midpoint of each element. By construction, the vector has full length and all of the other entries are zero. This requires slightly more memory, but allows for easy summation of all the derivatives.","category":"page"},{"location":"algorithm/#convex-problem-theory","page":"Algorithm","title":"Convex Problem","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The first term of the objective functional can be understood as a norm and can be discretized using the previously introduced derivative matrices by","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Vert u+g Vert_X^p(Omega)^p \n    = int_Omega Vert nabla u+g Vert_2^p mathrmd x\n    approx sum_i=1^m omega_i\n        left(sum_j=1^d sum_r=1^d^prime D^(jr)u + b_i^2right)^fracp2","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Note that for functions v in W^1p_g(OmegaR^d) it is possible to find a decomposition v = u + g such that u in W^1p_0(OmegaR^d) and g in W^1p_g(OmegaR^d) fixed. This means, we can consider a fixed prolongation of the Dirichlet condition to the full domain, pre-compute b^(jr) = D^(jr)g and then just minimize over u in W^1p_0(OmegaR^d) with homogeneous Dirichlet conditions in the relevant parts.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The second and the third term are standard integrals and can be discretized by mass matrices M and barM on the domain and the boundary, respectively. Now we can simply obtain a finite version of the problem by reformulating the summation as a scalar product and introduce a slack variable for the non-linear term:  ","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Minimizing the p-Laplace objective functional over the relevant finite element space is equivalent to the standard convex problem","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"min_x in mathcalQ_p langle cx rangle text with  c = \n    beginbmatrix\n        -Mf-barMh \n        fracomegap\n    endbmatrix","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"with a bounded and convex search set given by","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"mathcalQ_p = left \n    (us) in mathbbR^n times mathbbR^m   \n    s_i geq left(sum_j=1^d sum_r=1^d^prime \n        D^(jr)(u+g)_i^2right)^fracp2\n    land omega_i s_i leq R right\n","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"In order to obtain the boundedness of the set with the second condition, an additional constraint","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"omega_i Vert nabla (u+g)vert_K_iVert_2^p leq R","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"on the local gradients was added. Here, the constant R can be chosen large enough to not influence the solution. ","category":"page"},{"location":"algorithm/#path-following-theory","page":"Algorithm","title":"Path-Following","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The main part of the implementation is to efficiently solve this convex problem efficiently. Thus, in [1] is proposed to apply an interior-point method [4] which is well known in convex optimization. In this method, the problem is solved by approximately following the central path","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"x^*(t) = undersetx in mathcalQ_pmathrmargmin\n    t langle cx rangle + F(x)","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"for t rightarrow infty and during that staying sufficiently close by satisfying","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Vert tc + F^prime Vert^*_x leq beta","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Here beta is a given parameter and Vert cdot Vert_x^* denotes the norm induced by F or in particular by its symmetric positive definite Hessian F^primeprime at x.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Thus, in order to apply this method, we need a self-concordant barrier F of the  constrained search set as well as its first and second derivatives. We obtain this self-concordant barrier for mathcalQ_p by ","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"F_p(us) = -sum_i=1^m logz_i -sum_i=1^m logs_i -sum_i=1^m logtau_i","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"where","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"z_i(us) = s^frac2p - sum_j=1^d sum_r=1^d^prime D^(jr)u + b_i^2 \n    qquadtextandqquad tau_i(s) = R - omega_i s_i","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The derivatives can be found in the literature [4].","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"The general solution procedure then consists of two phases. An auxiliary phase to compute a suitable starting point, and after that a main phase to actually solve the constrained problem up to the given accuracy. Details can be found in [1,3]. Here, we will only show the key steps for the simplest variant, the short-step path-following.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"For the auxiliary path-following, we start with t_0 = 1, an arbitrary x_0 in mathcalQ_p and set G =  -F^prime(x_0). Then we iterate over","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"t_k+1 = t_k - fracgammaVert G Vert^*_x_k\nx_k+1 = x_k - F^primeprime(x_k)^-1 (t_k+1 G + F^prime(x_k))","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"until Vert F^prime(x_k) Vert^*_x_k leq fracsqrtbeta1+sqrtbeta. Doing an additional update step, we then get an x in mathcalQ_p such that  Vert F^prime(x) Vert^*_x_k leq beta, which is a necessary condition for the starting guess in the next phase.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"In the main path-following, the iteration is quite similar. However, we start with t_0 = 0, pick the final iterate from the previous phase as starting guess and use the system vector c instead of the negative initial gradient. The iteration then reads","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"t_k+1 = t_k + fracgammaVert c Vert^*_x_k\nx_k+1 = x_k - F^primeprime(x_k)^-1 (t_k+1 c + F^prime(x_k))","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"until t exceeds some given (inverse) tolerance. Note that 2. now corresponds to a classical Newton step for the central path.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"In the implementation, by default, an adaptive stepping with the proposed parameters from [1] is used. For comparison or numerically challenging problems, it can be beneficial to use the also implemented short- and long-step variants. But be aware that they usually require many more iterations, even if their theoretical worst-case estimate is better. Further, you can adjust all the parameters like step length and its updates by keyword arguments, if necessary.","category":"page"},{"location":"algorithm/#references-theory","page":"Algorithm","title":"References","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"[1] S. Loisel. “Efficient algorithms for solving the p-Laplacian in polynomial time”.     Numerische Mathematik. 2020.\n[2] P.M. Müller, N. Kühl, M. Siebenborn, K. Deckelnick, M. Hinze and T. Rung.     “A Novel p-Harmonic Descent Approach Applied to Fluid Dynamic Shape Optimization”.     Structural and Multidisciplinary Optimization. 2021.\n[3] Y. Nesterov. “Introductory lectures on convex optimization”.     Applied Optimization. 2004.\n[4] H. Wyschka and M. Siebenborn. “Towards computing high-order p-harmonic descent     directions and their limits in shape optimization”.     In: \"Modeling, Simulation and Optimization of Fluid Dynamic Applications\". 2023.","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"CurrentModule = PLaplace","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for PLaplace.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internal page of the library for the documentation  of internal types and functions.","category":"page"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 3","category":"page"},{"location":"lib/public/#Module","page":"Public","title":"Module","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"PLaplace","category":"page"},{"location":"lib/public/#PLaplace.PLaplace","page":"Public","title":"PLaplace.PLaplace","text":"PLaplace\n\nA Solver for Problems of the p-Laplacian PDE Operator.\n\nThis package imports the following packages:\n\nBase\nCore\nDocStringExtensions\nIncompleteLU\nInvertedIndices\nIterativeSolvers\nLinearAlgebra\nMinFEM\nPreconditioners\nPrintf\nSparseArrays\nWriteVTK\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#Algorithm","page":"Public","title":"Algorithm","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"PLaplaceData","category":"page"},{"location":"lib/public/#PLaplace.PLaplaceData","page":"Public","title":"PLaplace.PLaplaceData","text":"mutable struct PLaplaceData\n\nMain output type for solution of a p-Laplace problem. Stores all parameters and results obtained by the solution of a pLaplace problem. Can be used for Statistics, Error Analysis and writing the solution to a .vtk-file.\n\nFields\n\nmesh::Mesh: Mesh of computational domain.\ndirichlet_nodes::Set{Int64}: Dirichlet boundary of the computational domain.\nfixed_nodes::Union{Missing, Set{Int64}}: Fixed nodes on the boundary of the computational domain.\nneumann_elements::Union{Missing, Set{Int64}}: Neumann boundary of the computational domain.\nf::Union{Missing, AbstractVector{Float64}}: Domain source term.\nh::Union{Missing, AbstractVector{Float64}}: Neumann boundary condition.\nqdim::Int64: Number of components of the solution.\np::Float64: PDE parameter.\ngradient_bound::Union{Missing, Float64}: Upper bound for the gradient of the solution.\neps::Float64: Accuracy of the solution in a variational sense.\nstepsize::Stepsize: Stepping scheme of the interior point method.\nNaux::Union{Missing, Int64}: Number of iterations in the auxilliary path-following.         Is missing if algorithm did not reach auxilliary stage.\nNmain::Union{Missing, Int64}: Number of iterations for the main path-following         Is missing if algorithm did not reach main stage.\ntsetup::Union{Missing, Float64}: Time required for the setup         Is missing if algorithm did not reach setup stage.\ntaux::Union{Missing, Float64}: Time required for the auxilliary path-following         Is missing if algorithm did not reach auxilliary stage.\ntmain::Union{Missing, Float64}: Time required for the main path-following         Is missing if algorithm did not reach main stage.\ncalculation_nodes::Union{Missing, Set{Int64}}: Nodes on which the solution was computed, i.e. nodes without Dirichlet condtion.         Is missing if algorithm failed during setup stage.\ng::Union{Missing, AbstractVector{Float64}}: Dirichlet boundary condition prolonged to the whole domain.         Is missing if algorithm failed during setup stage.\nu::Union{Missing, AbstractVector{Float64}}: Shifted solution on calculation nodes without prolonged boundary condition.         Is missing if algorithm did not converge.\nv::Union{Missing, AbstractVector{Float64}}: Solution to the p-Laplace problem.             Is missing if algorithm did not converge.\nmsg::String: Notifications from the iteration. In particular contains changes of solvers and         preconditioners and information on early stops.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/","page":"Public","title":"Public","text":"solve_plaplace","category":"page"},{"location":"lib/public/#PLaplace.solve_plaplace","page":"Public","title":"PLaplace.solve_plaplace","text":"solve_plaplace(\n    p::Float64,\n    mesh::Mesh,\n    g::Union{AbstractVector{Float64}, Function},\n    dirichlet_boundary::Set{Boundary};\n    <keyword arguments>\n) -> PLaplaceData\n\nReturns solution to a given problem for the p-Laplace operator with a Dirichlet condition on (a part of) the boundary. Additionally, a volume source term and Neumann conditions on a non-intersecting part of the boudary can be specified. The solution is computed by an interior-point method applied to a reformulated problem. For more information on the algorithm, please look at the algorithm page of the documentation.\n\nBelow you find a list of mandatory and keyword arguments indicating which functions can be specified continously or discrete and which parameters can be adjusted. Further, the outputs can be controlled in particular if log and vtk files are generated. It is also possible to track the condition number of the system matrix during the iteration, but please not that this significantly impacts the performance and requires a lot of memory. \n\nMandatory Arguments\n\np::Float64: problem parameter.\nmesh::Mesh: FEM mesh of the domain.\ng::Union{AbstractVector{Float64}, Function}: Dirichlet boundary condition.\ndirichlet_boundary::Union{Set{Boundary}, Set{Int64}}: Parts of the physical boundary to   hold the Dirichlet condition. Either given by set of named boundaries or node ids.\n\nKeyword Arguments\n\nf::Union{AbstractVector{Float64}, Function, Missing} = missing:   Discrete or continous source term.\nneumann_boundary::Union{Set{Boundary}, Set{Int64}, Missing} = missing:   Parts of the physical boundary to hold Neumann condition.   Either given by set of named boundaries or boundary element ids.\nh::Union{AbstractVector{Float64}, Function, Missing} = missing:   Discrete or continous Neumann boundary condition. Requires neumann_boundary to be set.\nboundary_prolongation::Union{AbstractVector{Float64}, Missing} = missing:   Prescribed discrete prolongation of the Dirichlet condition to the full domain.   Will be computed during the algorithm if not set.\nfixed_nodes::Union{Set{Boundary}, Set{Int64}, Missing} = missing,:   Set of fixed node indices, i.e. additional homogeneous Dirichlet nodes.   Either given by set of named boundaries or node ids.   Is ignored if boundary_prolongation is set.\nqdim::Int64 = 1:   Number of components of the problem, respectively f, g and h as well as u and v.   Is mandatory to set for vector-valued setting.\neps::Float64 = 1e-6:   Accuracy of the solution.   In particular termination criterion for the main path-following.\nstepsize::Stepsize = ADAPTIVE:   Specifier for using an alternative stepping scheme in the internal path-following.\nmaxiterations::Int64 = 1000:   Maximal number of iteriations per stage of the internal path-following schemes.\nkappa::Float64 = 10.0:   Parameter used for updates of the step length in long-step path-following variants.\nbacktracking_maxiterations::Int64 = 25:    Maximal number of iterations in backtracking search for the update of the iterate   in long-step path-following variants.\nbacktracking_decrementfactor::Float64 = 0.25:   Decrement factor in backtracking search of long-step path-following variants.\nsolver::LinearSolver = CHOLESKY:   Specifier for the solver internally used for linear systems.\npreconditioner::Preconditioner = NONE:   Specifier for the preconditioner internally used for linear systems.\nuseharmonicprolongation::Bool = true:   Flag for prolongation of boundary condition as solution to the harmonic problem or by 0.   Is ignored if boundary_prolongation is set.\nvtkfile::Union{String,Missing} = missing:   File name for writing solution to vtk. If not set, no file will be written.\nverbose::Bool = true:   Flag if log is written to console during the iteration.\nlogfile::Union{String,Missing} = missing:   File name for writing log to a file. If not set, log will not be exported.\nlogcondition::Bool = false:   Flag for tracking condition of the system matrix is tracked and included in log file.   Will only be exported if logfile is set.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Keyword-Types","page":"Public","title":"Keyword Types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Stepsize\nLinearSolver\nPreconditioner","category":"page"},{"location":"lib/public/#PLaplace.Stepsize","page":"Public","title":"PLaplace.Stepsize","text":"primitive type Stepsize <: Enum{Int32} 32\n\nPublic type used to specify the stepping scheme of the path-following schemes. For more information see the interior-point section in the documentation.\n\nAvailable Options\n\nSHORT:   Regular update of the paramter t.\nLONG:   Larger update of the parameter t if iterate fulfill approximate centering conditon.   Results in line-search for application of update on the iterate x.\nADAPTIVE:   Same as the long stepping, but the factor for the larger update is adaptively changed   depending on how many steps it required to fulfill the approximate centering condition.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PLaplace.LinearSolver","page":"Public","title":"PLaplace.LinearSolver","text":"primitive type LinearSolver <: Enum{Int32} 32\n\nPublic type used to specify the linear solver in the solution algorithm.\n\nAvailable Options\n\nLU:   Direct solver with LU decomposition.\nCHOLESKY:   Direct solver with Cholesky decomposition.   Default options since Hessian is supposed to be symmetric positive definite.\nCG:   Iterative solver using the conjugate gradients methods.\nBICGSTAB:   Iterative solver using the bi-conjugate gradients stabilized method.\nGMRES:   Iterative solver using the generalized minimal residual method.   Has proven convergence for unsymmetric systems, but requires a lot of memory.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PLaplace.Preconditioner","page":"Public","title":"PLaplace.Preconditioner","text":"primitive type Preconditioner <: Enum{Int32} 32\n\nPublic type used to specify a preconditioner for the linear systems in the solution process.\n\nAvailable Options\n\nNONE:   Dummy option for no preconditioner. In particular used with direct solvers.\nJACOBI:   Preconditioner with diagonal matrix.\nILU:   Preconditioner with incomplete LU decomposition.\nICHOLESKY:   Preconditioner with incomplete Cholesky decomposition.\nAMG:   Preconditioner with algebraic multi-grid.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Initial-prolongations","page":"Public","title":"Initial prolongations","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"compute_prolongation_harmonic\ncompute_prolongation_zero","category":"page"},{"location":"lib/public/#PLaplace.compute_prolongation_harmonic","page":"Public","title":"PLaplace.compute_prolongation_harmonic","text":"compute_prolongation_harmonic(\n    g::AbstractVector{Float64},\n    mesh::Mesh,\n    has_sourceterm::Bool,\n    f::AbstractVector{Float64}, \n    dirichlet_nodes::Set{Int64},\n    has_neumannboundary::Bool,\n    h::AbstractVector{Float64},\n    neumann_elements::Set{Int64}, \n    solveLS::Function,\n    preconditioner::Function;\n    qdim::Int64 = 1\n) -> AbstractVector{Float64}\n\nReturns discrete prolongation of the boundary condition g to the whole domain as solution of the corresponding linear Laplace problem, i.e. p = 2.\n\nMandatory Arguments\n\ng::AbstractVector{Float64}: Discretely evaluated boundary condition.\nmesh::Mesh: Mesh of the domain.\nhas_sourceterm::Bool: Flag for evaluating source term.\nf::AbstractVector{Float64}: Source term.\ndirichlet_nodes::Set{Int64}: Nodes of the boundary to hold Dirichlet condition.\nhas_neumannboundary::Bool: Flag for evaluating Neumann boundary.\nh::AbstractVector{Float64}: Neumann boundary condition.\nneumann_elements::Set{Int64}: Edges of the boundary to hold Neumann condition.\nsolveLS::Function: Function pointer to solve linear system.\npreconditioner::Function: Function pointer to compute preconditioner for linear system.\n\nKeyword Arguments\n\nqdim::Int64 = 1: Number of components of f, h and g.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.compute_prolongation_zero","page":"Public","title":"PLaplace.compute_prolongation_zero","text":"compute_prolongation_zero(\n    g::AbstractVector{Float64},\n    mesh::Mesh;\n    qdim::Int64 = 1\n) -> AbstractVector{Float64}\n\nReturns discrete prolongation of g to the whole domain by zero on every node.\n\nReturns discrete prolongation of the boundary condition g to the whole domain by zero on every node.\n\nMandatory Arguments\n\ng::AbstractVector{Float64}: Discretely evaluated boundary condition.\nmesh::Mesh: Mesh of the domain.\n\nKeyword Arguments\n\nqdim::Int64 = 1: Number of components of f, h and g.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#FEM","page":"Public","title":"FEM","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"MinFEM.Mesh\nMinFEM.Boundary","category":"page"},{"location":"lib/public/#MinFEM.Mesh","page":"Public","title":"MinFEM.Mesh","text":"mutable struct Mesh\n\nType for a triangular finite element mesh with volume and boundary markers.\n\nFields\n\nd::Int64: Spatial dimension\nnnodes::Int64: Number of nodes\nnelems::Int64: Number of elements\nnboundelems::Int64: Number of physical (marked) boundary elements\nNodes::Vector{Vector{Float64}}: List of node coordinates\nElements::Vector{Vector{Int64}}: List of element node indices\nBoundaryElements::Vector{Vector{Int64}}: List of boundary element node indices\nParentElements::Vector{Int64}: List of parent elements to boundary elements\nParentBoundaries::Vector{Int64}: List of parent element local boundary to boundary elements\nBoundaries::Dict{Int64, Boundary}: Dictionary of marked boundaries\nDomains::Dict{Int64, Domain}: Dictionary of marked volume regions\nEntities::Vector{Dict{Int64, MinFEM.Entity}}: Dictionary of physical entities\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MinFEM.Boundary","page":"Public","title":"MinFEM.Boundary","text":"mutable struct Boundary <: MinFEM.Region\n\nStructure holding the name and sets of node and edge indices for one particular physical boundary.\n\nFields\n\nName::String: Unique physical name\nNodes::Set{Int64}: List of node indices\nElements::Set{Int64}: List of element indices\n\n\n\n\n\n","category":"type"},{"location":"lib/public/","page":"Public","title":"Public","text":"MinFEM.import_mesh\nMinFEM.select_boundaries","category":"page"},{"location":"lib/public/#MinFEM.import_mesh","page":"Public","title":"MinFEM.import_mesh","text":"import_mesh(fileName::String) -> Mesh\n\n\nReturns a mesh imported from a gmsh file of version v1, v2 or v4.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.select_boundaries","page":"Public","title":"MinFEM.select_boundaries","text":"select_boundaries(mesh::Mesh, args...) -> Set{Boundary}\n\n\nReturns set of all or specified physical boundaries of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Modified-Derivatives","page":"Public","title":"Modified Derivatives","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"assemble_derivativetensor\nassemble_derivativetensor_boundary\nassemble_derviativetensor_modified\ncompute_derivative\ncompute_normalderivative","category":"page"},{"location":"lib/public/#PLaplace.assemble_derivativetensor","page":"Public","title":"PLaplace.assemble_derivativetensor","text":"assemble_derivativetensor(\n    mesh::Mesh;\n    qdim::Int64 = 1\n) -> Dict{Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\nReturns the discrete derivative tensor for all elements of mesh and the number of components of the function qdim. Each key tuple (j,r) represents the derivative matrix for the component r in direction x_j.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.assemble_derivativetensor_boundary","page":"Public","title":"PLaplace.assemble_derivativetensor_boundary","text":"assemble_derivativetensor_boundary(\n    mesh::Mesh,\n    BoundaryElements::Set{Int64}; \n    qdim::Int64 = 1\n) -> Dict{Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\nReturns the discrete derivative tensor for all or specified boundary elements of mesh and number of components qdim. Each key tuple (j,r) represents the derivative matrix for the component r in direction x_j. Workaround based on the derivate tensor for the corresponding full element and the fact that the gradient is constant on the element. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.assemble_derviativetensor_modified","page":"Public","title":"PLaplace.assemble_derviativetensor_modified","text":"assemble_derviativetensor_modified(\n    D::AbstractDict{Tuple{Int64,Int64},SparseMatrixCSC{Float64,Int64}},\n    nodesToDrop::Set{Int64};\n    qdim::Int64 = 1\n) -> Dict{Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\nReturns a new derivative tensor reduced by nodesToDrop, e.g used to drop homogeneous Dirichtlet boundary points of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.compute_derivative","page":"Public","title":"PLaplace.compute_derivative","text":"compute_derivative(\n    D::AbstractDict{Tuple{Int64,Int64},SparseMatrixCSC{Float64,Int64}},\n    v::AbstractVector{Float64}\n) -> Dict{Tuple{Int64, Int64}, AbstractVector{Float64}}\n\nReturs coefficient vectors of all the first partial derivatives D^(jr)v of a function given as coefficient vector v using the discrete derivative tensor D. Each key tuple (j,r) represents the derivative of the component r in direction x_j.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.compute_normalderivative","page":"Public","title":"PLaplace.compute_normalderivative","text":"compute_normalderivative(\n    mesh::Mesh,\n    boundary::Set{Boundary},\n    v::AbstractVector{Float64};\n    qdim::Int64 = 1\n) -> Dict{Tuple{Int64, Int64}, AbstractVector{Float64}}\n\nReturns normal derivative of a function on all or specified boundary elements of the mesh. Each key r represents the derivative of the component r in outer normal direction.\n\n\n\n\n\ncompute_normalderivative(\n    mesh::Mesh,\n    boundary::Set{Boundary},\n    v::AbstractVector{Float64};\n    qdim::Int64 = 1\n) -> Dict{Tuple{Int64, Int64}, AbstractVector{Float64}}\n\nSame as previous compute_normalderivative(...). However takes Set{Boundary} of named boundary objects as argument boundary and translates it to a Set{Int64} containing the indices of the nodes contained in the given boundaries.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Statistics","page":"Public","title":"Statistics","text":"","category":"section"},{"location":"lib/public/#PLaplace-Data","page":"Public","title":"PLaplace Data","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"hasresult\nwrite_result_to_vtk\nwrite_result_to_txt\nprint_defaultdata\nprint_statistics\nwrite_statistics_header\ncheck_statistics_header\nwrite_statistics","category":"page"},{"location":"lib/public/#PLaplace.hasresult","page":"Public","title":"PLaplace.hasresult","text":"hasresult(data::PLaplaceData) -> Bool\n\n\nReturns if the object contains a result, i.e. if an algorithm ran and converged. Should be called before the result is used via data.v.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.write_result_to_vtk","page":"Public","title":"PLaplace.write_result_to_vtk","text":"write_result_to_vtk(\n    filename::String,\n    data::PLaplaceData\n) -> Union{Nothing, Vector{String}}\n\n\nWrites result vector to a VTK file with the given name. The file itself will be created, but the path has to exist prior. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.write_result_to_txt","page":"Public","title":"PLaplace.write_result_to_txt","text":"write_result_to_txt(filename::String, data::PLaplaceData)\n\n\nWrites result vector to a VTK file with the given name. The file itself will be created, but the path has to exist prior. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.print_defaultdata","page":"Public","title":"PLaplace.print_defaultdata","text":"print_defaultdata(data::PLaplaceData) -> Any\n\n\nPrints problem data that had to be specified for the algorithm ot the console. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.print_statistics","page":"Public","title":"PLaplace.print_statistics","text":"print_statistics(data::PLaplaceData) -> Any\n\n\nPrints statistics of the algorithm run ot the console. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.write_statistics_header","page":"Public","title":"PLaplace.write_statistics_header","text":"write_statistics_header(filename::String; guarded::Bool=false)\n\nClears and writes a header for a statistics log to the given file. In case the file does not exist, it will be created, but only if the path exists. If guarded checks before if file already contains a header and then does not overwrite potentially previous results.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.check_statistics_header","page":"Public","title":"PLaplace.check_statistics_header","text":"check_statistics_header(filename::String) -> Bool\n\n\nChecks if given file exists and alredy contains a statistics header. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.write_statistics","page":"Public","title":"PLaplace.write_statistics","text":"write_statistics(\n    filename::String,\n    data::PLaplaceData\n) -> Int64\n\n\nWrites statistics line corresponding to the header to a given log file. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Log-Data","page":"Public","title":"Log Data","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"AlgorithmLogData\nread_algorithmlog","category":"page"},{"location":"lib/public/#PLaplace.AlgorithmLogData","page":"Public","title":"PLaplace.AlgorithmLogData","text":"mutable struct AlgorithmLogData\n\nStores data read from an algorithm log file. Can be used to generate plots from one solution process. \n\nFields\n\ntotalIterations::Vector{Union{Missing, Int64}}: Running number of total iterations for each iteration.\nsections::Vector{String}: Section tag in each iteration.\npartIterations::Vector{Union{Missing, Int64}}: Running number of iterations in current section for each iteration.\ntypes::Vector{Union{Missing, String}}: Tag for type of the update step for each iteration.         Only relevant for long and adaptive stepping schemes.\nlastaccepts::Vector{Union{Missing, Int64}}: Number of iterations since previous accept for each iteration         Only relevant for adaptive stepping scheme.\nkappas::Vector{Union{Missing, Float64}}: Parameter kappa for each iteration. Only relevant for adaptive stepping scheme.\naccnorms::Vector{Union{Missing, Float64}}: Norm value for acceptance of step for each iteration.         Only relevant for long and adaptive stepping schemes.\nsearchIterations::Vector{Union{Missing, Int64}}: Number of iterations in backtracking linesearch for each iteration.         Only relevant for long and adaptive stepping schemes\nscalings::Vector{Union{Missing, Float64}}: Scaling of the update generated by the backtracking for each iteration.         Only relevant for long and adaptive stepping schemes.\nts::Vector{Union{Missing, Float64}}: Value of t for each iteration.\ncriteria::Vector{Union{Missing, Float64}}: Value of convergence criterum for each iteration.\nbounds::Vector{Union{Missing, Float64}}: Bound for convergence criteria for each iteration. Is constant per section.\nconditions::Vector{Union{Missing, Float64}}: Condition number of the system matrix for each iteration.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PLaplace.read_algorithmlog","page":"Public","title":"PLaplace.read_algorithmlog","text":"read_algorithmlog(filename::String)\n\nReturns AlgorithmLogData by reading the given algorithm log file.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Error-Analysis","page":"Public","title":"Error Analysis","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"ErrorData","category":"page"},{"location":"lib/public/#PLaplace.ErrorData","page":"Public","title":"PLaplace.ErrorData","text":"mutable struct ErrorData\n\nStructure to hold error values compared to analytical solutions for multiple computations. Can be used to generate plots.\n\nFields\n\np::Vector{Float64}: PDE parameters.\nn::Vector{Int64}: Number of gridpoints\neps::Vector{Float64}: Accuracy\nerrors::Vector{Vector{Float64}}: Errors\n\n\n\n\n\n","category":"type"},{"location":"lib/public/","page":"Public","title":"Public","text":"objective_functional\ncompute_errors","category":"page"},{"location":"lib/public/#PLaplace.objective_functional","page":"Public","title":"PLaplace.objective_functional","text":"objective_functional(\n    u::AbstractVector{Float64},\n    p::Float64,\n    mesh::Mesh; \n    f::Union{AbstractVector{Float64}, Function, Missing} = missing,\n    neumann_boundary::Union{Set{Boundary}, Set{Int64}, Missing} = missing,\n    h::Union{AbstractVector{Float64}, Function, Missing} = missing,\n    qdim::Int64 = 1\n) -> Float64\n\nReturns value of variational formulation functional for the p-Laplace problem evaluated at u. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.compute_errors","page":"Public","title":"PLaplace.compute_errors","text":"compute_errors(\n    anasol::Vector{Float64},\n    numsol::Vector{Float64},\n    mesh::Mesh,\n    neumann_boundary::Union{Missing, Set{Int64}, Set{Boundary}},\n    h::Union{Missing, AbstractVector{Float64}},\n    f::Union{Missing, AbstractVector{Float64}},\n    p::Float64,\n    qdim::Int64\n) -> Vector{Float64}\n\n\nReturns various errors of numerical solution compared to given  discretized analytical solution.  First value is error in difference in objective value, then pointwise error L1, L2 and LInf norm.\n\nIntended to be called via a wrapper to ensure the discretized analytical solution and the numerical solution match the mesh.\n\n\n\n\n\ncompute_errors(\n    anasol::Vector{Float64},\n    data::PLaplaceData\n) -> Vector{Float64}\n\n\nSame as previous compute_errors(...). However takes discretized analytical solution and PLaplaceData(@ref) as arguments.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/","page":"Public","title":"Public","text":"write_error_header\ncheck_error_header\nwrite_error\nread_error\nappend!(A::ErrorData, B::ErrorData) ","category":"page"},{"location":"lib/public/#PLaplace.write_error_header","page":"Public","title":"PLaplace.write_error_header","text":"write_error_header(filename::String; guarded) -> Int64\n\n\nClears and writes a header for an error log to the given file. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.check_error_header","page":"Public","title":"PLaplace.check_error_header","text":"check_error_header(filename::String) -> Bool\n\n\nChecks if given file exists and alredy contains an error header. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.write_error","page":"Public","title":"PLaplace.write_error","text":"write_error(\n    file_name::String,\n    data::PLaplaceData,\n    error::Vector{Float64}\n) -> Int64\n\n\nWrites a given error along other information corresponding to the header to a given file.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.read_error","page":"Public","title":"PLaplace.read_error","text":"read_error(fileName::String) -> ErrorData\n\n\nReturns ErrorData when handed an file generated by PLaplace. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.append!-Tuple{ErrorData, ErrorData}","page":"Public","title":"Base.append!","text":"append!(\n    A::ErrorData,\n    B::ErrorData\n) -> Vector{Vector{Float64}}\n\n\nAppends to objects of type ErrorData by appending all elements of B to the elements in A.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Other-Utilities","page":"Public","title":"Other Utilities","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"xpnorm\ncompute_lipschitzconstant_boundary","category":"page"},{"location":"lib/public/#PLaplace.xpnorm","page":"Public","title":"PLaplace.xpnorm","text":"xpnorm(\n    p::Float64,\n    dv::AbstractDict{Tuple{Int64, Int64}, AbstractVector{Float64}},\n    w::AbstractVector{Float64}\n) -> Float64\n\n\nReturns Vert f Vert^p_X_p(Omega) = int_Omega Vert  f(x) Vert_2^p mathrmdx in FEM representaion, i.e.\n\nVert f Vert^p_X_p(T_h_Omega) =\n    sumlimits_i=1^m omega_i \n    left(sumlimits_j=1^d sumlimits_r=1^d^prime\n    D^(jr) v_i^2 right)^fracp2\n\nParameters can either be given as a function and a mesh or with the function as FEM coefficient vector and a derivative tensor.\n\nMandatory Arguments\n\np::Float64: Parameter for the norm.\ndv::AbstractDict{Tuple{Int64,Int64},AbstractVector{Float64}}: Discrete derivative of   function v given at the quadrature nodes of the elements in T_h_Omega.\nw::AbstractVector{Float64}: Vector of weights corresponding to the quadrature nodes.\n\n\n\n\n\nxpnorm(\n    p::Float64,\n    v::AbstractVector{Float64},\n    D::AbstractDict{Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}},\n    w::AbstractVector{Float64}\n) -> Float64\n\n\nDoes the same as previous xpnorm(...), but takes coefficient vector and derivate tensor as arguments instead of derivative vector.\n\nRequires new mandatory arguments\n\nv::AbstractVector{Float64}: Function discretely evaluated at the nodes of a mesh.\nD::AbstractDict{Tuple{Int64,Int64},SparseMatrixCSC{Float64,Int64}}: Discrete derivative   tensor corresponding to the same nodes as v.\n\nwhich replace\n\ndv::AbstractDict{Tuple{Int64,Int64},AbstractVector{Float64}}\n\n\n\n\n\nxpnorm(\n    p::Float64,\n    f::Function,\n    mesh::Mesh;\n    qdim::Int64 = 1\n) -> Float64\n\nDoes the same as previous xpnorm(...), but takes a continous function and a mesh as arguments instead of a discrete derivative (tensor) and coefficient vector.\n\nRequires new mandatory arguments\n\nf::Function: Analytic description of the function to be evaluated.\nmesh::Mesh: FEM mesh corresponding to T_h_Omega.\n\nwhich replace\n\ndv::AbstractDict{Tuple{Int64,Int64},AbstractVector{Float64}}\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PLaplace.compute_lipschitzconstant_boundary","page":"Public","title":"PLaplace.compute_lipschitzconstant_boundary","text":"compute_lipschitzconstant_boundary(\n    gh::Array{Float64,1},\n    coords::Array{Array{Float64,1},1},\n    boundaryNodes::Set{Int64};\n    qdim::Int64 = 1,\n    pnorm::Real = 2\n)\n\nReturns Lipschitz constant of function g given as FEM coefficient vector on a boundary of the mesh.\n\nMandatory Arguments\n\ngh::Array{Float64,1}: Function discretely evaluated on a mesh.\ncoords::Array{Array{Float64,1},1}: Array of coordinates of the nodes gh was evaluated   on. In particular contains the coordinates of the boundaryNodes.\nboundaryNodes::Set{Int64}: Set of nodes, i.e. entries in coords that belong to the   boundary that shall be evaluated. Therefore also selects entries of gh. Potentially   shifted by qdim.\n\nKeyword Arguments\n\nqdim::Int64 = 1: Number of components of the function gh.\npnorm::Real = 2: Parameter of p-norm used to measure internal distances.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"(Image: PLaplace Logo)","category":"page"},{"location":"#PLaplace.jl","page":"Home","title":"PLaplace.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Solver for Problems of the p-Laplacian PDE Operator.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a solver for problems of the scalar or vector-valued p-Laplacian with finite p  including source terms and mixed Dirichlet-Neumann boundary conditions. The solver works iteratively based on a piece-wise linear finite element discretization and interior-point methods. Theory can be found in the publications [1] and  [3] as well as a short description on the algorithm page. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on the finite element library MinFEM.jl. Thus, it is able to import meshes in GMSH v1, v2 and v4 format and outputs VTK format for Paraview as well as statistics in plain txt.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start by adding the PLaplace package to our julia installation and test it. Note that the test might take some time depending on your machine, since it solves a full validation problem provided by the method of manufactured solutions [2]. Thus, open the julia REPL, hit the ] key and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"add PLaplace\ntest PLaplace","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Examples section features some demonstrations for different types of problems that can be solved using this package. This only showcases parts of the functionalities, but gives an idea of the usage. Original code files are in addition available in the  GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/dirichlet-square.md\",\n    \"examples/neumann-square.md\",\n    \"examples/vector-neumann-cube.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For more experienced users, we further offer the Library with a full list of types, functions and methods provided by PLaplace featuring explicit documentation. This also includes extensions of the algorithm not used for the tutorials showed in this documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internal.md\"]\nDepth = 1","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] S. Loisel. “Efficient algorithms for solving the p-Laplacian in polynomial time”.     Numerische Mathematik. 2020.\n[2] K. Salari and P. Knupp. “Code Verification by the Method of Manufactured Solutions”. Sandia Report. 2000.\n[3] H. Wyschka and M. Siebenborn. “Towards computing high-order p-harmonic descent     directions and their limits in shape optimization”.     In: \"Modeling, Simulation and Optimization of Fluid Dynamic Applications\". 2023.","category":"page"},{"location":"lib/internal/#Internal-Documentation","page":"Internal","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"","category":"page"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"CurrentModule = PLaplace","category":"page"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Documentation for PLaplace.jl's internal types and methods.","category":"page"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"See the Public page of the library for the documentation  of the public interface.","category":"page"},{"location":"lib/internal/#Contents","page":"Internal","title":"Contents","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Pages = [\"internal.md\"]\nDepth = 3","category":"page"},{"location":"lib/internal/#Utility","page":"Internal","title":"Utility","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"utility.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.emptyfunction-Tuple","page":"Internal","title":"PLaplace.emptyfunction","text":"emptyfunction(args...)\n\n\nDummy function for do nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Linear-Systems","page":"Internal","title":"Linear Systems","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"linearsystems.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.factorization_none-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Internal","title":"PLaplace.factorization_none","text":"factorization_none(\n    A::SparseArrays.SparseMatrixCSC{Float64, Int64}\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nWrapper for not computing a factorization of a matrix A, but keeping the matrix itself. Can be used as do nothing factorization for iterative linear solvers.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.preconditioner_amg-Tuple{SparseArrays.AbstractSparseMatrix{Float64, Ti} where Ti}","page":"Internal","title":"PLaplace.preconditioner_amg","text":"preconditioner_amg(\n    A::SparseArrays.AbstractSparseMatrix{Float64, Ti} where Ti\n) -> Preconditioners.AMGPreconditioner{Preconditioners.RugeStuben, _A, AlgebraicMultigrid.V} where _A<:AlgebraicMultigrid.MultiLevel\n\n\nWrapper for computing an algebraic multi-grid preconditioner for a matrix A.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.preconditioner_illt-Tuple{SparseArrays.AbstractSparseMatrix{Float64, Ti} where Ti}","page":"Internal","title":"PLaplace.preconditioner_illt","text":"preconditioner_illt(\n    A::SparseArrays.AbstractSparseMatrix{Float64, Ti} where Ti\n) -> Preconditioners.CholeskyPreconditioner{_A} where _A\n\n\nWrapper for computing an incomplete Cholesky preconditioner for a matrix A.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.preconditioner_ilu-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Internal","title":"PLaplace.preconditioner_ilu","text":"preconditioner_ilu(\n    A::SparseArrays.SparseMatrixCSC{Float64, Int64}\n) -> IncompleteLU.ILUFactorization{Float64, Int64}\n\n\nWrapper for computing an incomplete LU preconditioner for a matrix A.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.preconditioner_jacobi-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Internal","title":"PLaplace.preconditioner_jacobi","text":"preconditioner_jacobi(\n    A::SparseArrays.SparseMatrixCSC{Float64, Int64}\n) -> Preconditioners.DiagonalPreconditioner{Float64, Vector{Float64}}\n\n\nWrapper for computing a Jacobi (/Diagonal) preconditioner for a matrix A.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.preconditioner_none-Tuple{Any}","page":"Internal","title":"PLaplace.preconditioner_none","text":"preconditioner_none(A) -> LinearAlgebra.UniformScaling{Bool}\n\n\nWrapper for computing a preconditioner for a matrix A or its factorization without effect, i.e. returns identity.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.select_linearsolver-Tuple{LinearSolver}","page":"Internal","title":"PLaplace.select_linearsolver","text":"select_linearsolver(\n    solver::LinearSolver\n) -> Tuple{Function, Function}\n\n\nReturns pair of functions of the actual solving routine and the factorization routine for the given linear solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.select_preconditioner-Tuple{Preconditioner}","page":"Internal","title":"PLaplace.select_preconditioner","text":"select_preconditioner(\n    preconditioner::Preconditioner\n) -> Function\n\n\nReturns function for computing the given preconditioner.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.solve_bicgstab-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, AbstractVector{Float64}, Any}","page":"Internal","title":"PLaplace.solve_bicgstab","text":"solve_bicgstab(\n    A::SparseArrays.SparseMatrixCSC{Float64, Int64},\n    b::AbstractVector{Float64},\n    P\n) -> Any\n\n\nWrapper for solving linear system with a preconditioned stabilized bi-conjugated gradients method.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.solve_cg-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, AbstractVector{Float64}, Any}","page":"Internal","title":"PLaplace.solve_cg","text":"solve_cg(\n    A::SparseArrays.SparseMatrixCSC{Float64, Int64},\n    b::AbstractVector{Float64},\n    P\n) -> Any\n\n\nWrapper for solving linear system with a preconditioned conjugated gradients method.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.solve_default-Tuple{Any, AbstractVector{Float64}, Any}","page":"Internal","title":"PLaplace.solve_default","text":"solve_default(A, b::AbstractVector{Float64}, P) -> Any\n\n\nWrapper for solving linear system with julias default \\ operator. Usually intended to be called not with a matrix A itself but a factorization, e.g. LU or Cholesky.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.solve_gmres-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, AbstractVector{Float64}, Any}","page":"Internal","title":"PLaplace.solve_gmres","text":"solve_gmres(\n    A::SparseArrays.SparseMatrixCSC{Float64, Int64},\n    b::AbstractVector{Float64},\n    P\n) -> Any\n\n\nWrapper for solving linear system with a preconditioned GMRES.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Static-Data","page":"Internal","title":"Static Data","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"staticdata.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.StaticData","page":"Internal","title":"PLaplace.StaticData","text":"mutable struct StaticData\n\nStores all data that is static throughout iteration of the interior-point method. Is supposed to be generated by corresponding constructor.\n\nFields\n\np::Float64: PDE parameter\nd::Int8: Domain dimension\nqdim::Int64: Image dimension, i.e. number of components\nn::Int64: Number of nodes in domain mesh\nm::Int64: Number of elements in domain mesh\ncalculation_nodes::Set{Int64}: Set of actually calculated nodes\nnCalc::Int64: Number of calculated nodes\nlengthu::Int64: Number of calculated FEM coefficients\nc::AbstractVector{Float64}: System vector for convex optimization problem\nR::Float64: Upper bound for auxilliary variable\nomega::AbstractVector{Float64}: Vector of element weights\nD::AbstractDict{Tuple{Int64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}: Discrete derivative matrix\ng::AbstractVector{Float64}: Prolonged boundary\nb::AbstractDict{Tuple{Int64, Int64}, AbstractVector{Float64}}: Discrete derivative of the prolonged boundary condition, i.e. Dg\nsigma::Int64: Constant for barrier self-concordance order\nalpha::Float64: Constant factor for barrier terms\nbeta::Float64: Algorithm constant given by Nesterov as 1/9\ngamma::Float64: Algorithm constant given by Nesterov as 5/36\ntolInv::Float64: Inverse tolerance used for main path-following termination\ntolFactor::Float64: Accuracy to tolerance factor\nmaxIter::Int64: Maximal number of iterations in path-following schemes\nkappa::Float64: Initial stepsize for long and adaptive path-following\nkappa_updates::Array{Int64, N} where N: Ranges of slow steps for update of kappa in adaptive path-following\nkappa_powers::Array{Float64, N} where N: Powers in the update that is applied to kappa in the relevant ranges\nmaxIterationsBacktracking::Int64: Maximal number of iterations for backtracking in long and adaptive path-following\ndecrementFactorBacktracking::Float64: Decrement factor for backtracking in long and adaptive path-following\nsolveLS::Function: Function pointer on solving routine\nfactorize::Function: Funciton pointer on factorization routine\ncomputePreconditioner::Function: Function pointer on preconditioner\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.StaticData-Tuple{Float64, Mesh, Set{Int64}, Union{Missing, Set{Int64}}, Union{Missing, Set{Int64}}, Union{Missing, AbstractVector{Float64}}, AbstractVector{Float64}, Union{Missing, AbstractVector{Float64}}, Union{Missing, AbstractVector{Float64}}, Int64, Float64, Int64, Float64, Array{Int64, N} where N, Array{Float64, N} where N, Int64, Float64, LinearSolver, Preconditioner, Bool}","page":"Internal","title":"PLaplace.StaticData","text":"StaticData(\n    p::Float64,\n    mesh::Mesh,\n    dirichlet_nodes::Set{Int64},\n    fixed_nodes::Union{Missing, Set{Int64}},\n    neumann_elements::Union{Missing, Set{Int64}},\n    f::Union{Missing, AbstractVector{Float64}},\n    g::AbstractVector{Float64},\n    h::Union{Missing, AbstractVector{Float64}},\n    boundary_prolongation::Union{Missing, AbstractVector{Float64}},\n    qdim::Int64,\n    eps::Float64,\n    maxIter::Int64,\n    kappa::Float64,\n    kappa_updates::Array{Int64, N} where N,\n    kappa_powers::Array{Float64, N} where N,\n    maxIterationsBacktracking::Int64,\n    decrementFactorBacktracking::Float64,\n    solver::LinearSolver,\n    preconditioner::Preconditioner,\n    useHarmonicProlongation::Bool\n) -> PLaplace.StaticData\n\n\nConstructor for a StaticData object. In particular computes boundary prolongation if required and its derviative, upper and lower bounds on the auxiliary variable as well as the system vector. \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.compute_sigma-Tuple{Float64}","page":"Internal","title":"PLaplace.compute_sigma","text":"compute_sigma(p::Float64) -> Int64\n\n\nReturns factor σ for the barrier function parameter depending on p.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.compute_systemvector-Tuple{Mesh, Float64, AbstractVector{Float64}, Set{Int64}, Bool, Union{Missing, Set{Int64}}, Union{Missing, AbstractVector{Float64}}, Bool, Union{Missing, AbstractVector{Float64}}, Int64}","page":"Internal","title":"PLaplace.compute_systemvector","text":"compute_systemvector(\n    mesh::Mesh,\n    p::Float64,\n    omega::AbstractVector{Float64},\n    dirichlet_nodes::Set{Int64},\n    has_neumannboundary::Bool,\n    neumann_elements::Union{Missing, Set{Int64}},\n    h::Union{Missing, AbstractVector{Float64}},\n    has_sourceterm::Bool,\n    f::Union{Missing, AbstractVector{Float64}},\n    qdim::Int64\n) -> Any\n\n\nComputes system vector c for a p-Poisson problem to solve with a barrier method.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.compute_upperbound-Tuple{Mesh, Float64, AbstractDict{Tuple{Int64, Int64}, AbstractVector{Float64}}, AbstractVector{Float64}, Bool, Union{Missing, Set{Int64}}, Union{Missing, AbstractVector{Float64}}, Bool, Union{Missing, AbstractVector{Float64}}, Int64}","page":"Internal","title":"PLaplace.compute_upperbound","text":"compute_upperbound(\n    mesh::Mesh,\n    p::Float64,\n    b::AbstractDict{Tuple{Int64, Int64}, AbstractVector{Float64}},\n    omega::AbstractVector{Float64},\n    has_neumannboundary::Bool,\n    neumann_elements::Union{Missing, Set{Int64}},\n    h::Union{Missing, AbstractVector{Float64}},\n    has_sourceterm::Bool,\n    f::Union{Missing, AbstractVector{Float64}},\n    qdim::Int64\n) -> Float64\n\n\nComputes constant upper bound R on the auxiliary variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Barriers","page":"Internal","title":"Barriers","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"barrierfunction.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.BarrierFunction","page":"Internal","title":"PLaplace.BarrierFunction","text":"BarrierFunction\n\nObject holdigng the relevant functions for evaluating a barrier function. Includes gradient and hessian as well as a specific initial guess.\n\nIs not intended to be initialized directly but via sub-constructors corresponding to specific barrier files. See their documentations belov to identify the behaviour of specific barrier implemtations. \n\nFields\n\nisadmissible::Function: Returns boolean value wether x is in the corresponding admissible set.\nvalue::Function: Returns float value of the barrier function at x.\ngradient::Function: Returns vector-valued gradient of the barrier function at x.\nhessian::Function: Returns matrix-valued Hessian of the barrier function at x.\ninitialguess::Function: Returns inital vector guess for starting an auxilliary path-following.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.BarrierFunction-Tuple{}","page":"Internal","title":"PLaplace.BarrierFunction","text":"BarrierFunction() -> PLaplace.BarrierFunction\n\n\nWrapping constructor for the selection of a barrier function.\n\nFor the specific behaviour of a barrier see the documentation of the sub-constructors below.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.FiniteBarrier-Tuple{}","page":"Internal","title":"PLaplace.FiniteBarrier","text":"FiniteBarrier() -> PLaplace.BarrierFunction\n\n\nReturns BarrierFunction object corresponding to default barrier function for finite p.\n\nIn this setting the admissible set is given by\n\n    mathcalQ_p \n        = left (us) in mathbbR^n times mathbbR^m   \n        s_i geq left(sum_j=1^d sum_r=1^d\n        D^(jr)(u+g)_i^2 right)^fracp2\n        land omega_i s_i leq R right\n\nDefining the variables\n\n    z_i(us) = s^frac2p - sumlimits_j=1^d sumlimits_r=1^d\n        underbraceD^(jr)(u+g)_= y^(jr)(u)_i^2\n        quad textand quad tau_i(s) = R -omega_i s_i\n\nit can be equipped with the self-concordant barrier\n\n    F(x) = F(us) = -sumlimits_i=1^m log(z_i)\n        -sumlimits_i=1^m log(s_i)\n        -sumlimits_i=1^m log(tau_i)\n\nThe derivatives\n\n    F(x) = beginbmatrix F_u  F_s endbmatrix\n        text and \n        F(x) = beginbmatrix \n            F_uu  F_us \n            F_us^intercal  F_ss\n        endbmatrix\n\nare then given by\n\n    beginaligned\n        F_u =2 sum_j=1^d sum_r=1^d D^(jr)^intercal\n            fracy^(jr)z \n        F_s = -frac2pfrac1zs^frac2p-1 + fracomegatau\n        F_uu = 2 sum_j=1^d sum_r=1^d D^(jr)^intercal Z^-1\n            D^(jr) \n        quad+ 4 sum_j_1=1^d sum_r_1=1^dsum_j_2=1^d\n            sum_r_2=1^d (Y^(j_1r_1)D^(j_1r_1))^intercal Z^-1 D^(j)\n            (Y^(j_2r_2)D^(j_2r_2))\n        F_us = -frac4psum_j=1^d sum_r=1^d\n            (Y^(jr)D^(jr))^intercal Z^-2 S^frac2p-1\n        F_ss = -frac2p left(frac2p - 1 right) Z^-1 S^frac2p-2\n            + frac4p^2 Z^-2 S^frac4p-2 + W^2 T^-2\n        textwhere  S = mathrmdiag(s) W = mathrmdiag(omega)\n            Y = mathrmdiag(y) Z = mathrmdiag(z)\n            text and  T = mathrmdiag(tau)\n    endaligned\n\nAn initial guess inside mathcalQ_infty is given by\n\n    hatx = beginbmatrix \n            0 \n            hats\n        endbmatrix\n        in mathbbR^n times m\n\nwhere\n\n    hats = 1 + left(sum_j=1^d sum_r=1^d\n        D^(jr) g_i^2 right)^fracp2\n        in mathbbR^m\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Tracking","page":"Internal","title":"Tracking","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"tracking.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.AssemblyTracker","page":"Internal","title":"PLaplace.AssemblyTracker","text":"mutable struct AssemblyTracker\n\nTracks if factorization or preconditioner got changed during an assembly of the IterationData.\n\nAlso tracks condition of system of system matrix, i.e. the barrier Hessian. Has to be tracked via this tool because after the assembly the matrix is usually only available as factorization.\n\nFields\n\ntrackcondition::Bool: Flag if conditino is tracked.\nconditionnumber::Union{Missing, Float64}: Condition number of system matrix.\nsingularity::Bool: Flag if hessian is singular.\nfactorization::Bool: Flag if factorization got changed.\npreconditioner::Bool: Flag if precondtioner got changed.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.AssemblyTracker-Tuple{}","page":"Internal","title":"PLaplace.AssemblyTracker","text":"AssemblyTracker(;trackcondition::Bool = false)\n\nDefault constructor for AssemblyTracker.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.DescentTracker","page":"Internal","title":"PLaplace.DescentTracker","text":"mutable struct DescentTracker\n\nObject used to track the result of the application of a descent step. Usually done by a backtracking line search, it contains the required iterations, i.e. updates of the scaling parameter, the final scaling parameter and the required time.\n\nFields\n\ni::Int64: Number of iterations.\nval::Float64: Final scaling value\ntime::Union{Missing, Float64}: Required time\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.DescentTracker-Tuple{Int64, Float64}","page":"Internal","title":"PLaplace.DescentTracker","text":"DescentTracker(\n    i::Int64,\n    val::Float64\n) -> PLaplace.DescentTracker\n\n\nConstructor for creating a DescentTracker object with given iteration count and scaling parameter.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.DescentTracker-Tuple{}","page":"Internal","title":"PLaplace.DescentTracker","text":"DescentTracker() -> PLaplace.DescentTracker\n\n\nConstructor for creating a default DescentTracker object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.changed_factorization!-Tuple{PLaplace.AssemblyTracker}","page":"Internal","title":"PLaplace.changed_factorization!","text":"changed_factorization!(\n    tracker::PLaplace.AssemblyTracker\n) -> Bool\n\n\nSets flag of an AssemblyTracker that the factorization got changed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.changed_preconditioner!-Tuple{PLaplace.AssemblyTracker}","page":"Internal","title":"PLaplace.changed_preconditioner!","text":"changed_preconditioner!(\n    tracker::PLaplace.AssemblyTracker\n) -> Bool\n\n\nSets flag of an AssemblyTracker that the preconditioner got changed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.hessian_singular!-Tuple{PLaplace.AssemblyTracker}","page":"Internal","title":"PLaplace.hessian_singular!","text":"hessian_singular!(tracker::PLaplace.AssemblyTracker) -> Bool\n\n\nSets flag of an AssemblyTracker that the hessian is singular and no factorization was computed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.reset!-Tuple{PLaplace.AssemblyTracker}","page":"Internal","title":"PLaplace.reset!","text":"reset!(tracker::PLaplace.AssemblyTracker) -> Bool\n\n\nResets an AssemblyTracker to its default constructor values. Does not change outside flag if condition number is tracked.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.reset!-Tuple{PLaplace.DescentTracker}","page":"Internal","title":"PLaplace.reset!","text":"reset!(tracker::PLaplace.DescentTracker) -> Missing\n\n\nResets a DescentTracker to its default constructor values.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.set!-Tuple{PLaplace.DescentTracker, Int64, Float64}","page":"Internal","title":"PLaplace.set!","text":"set!(\n    tracker::PLaplace.DescentTracker,\n    i::Int64,\n    val::Float64\n) -> Float64\n\n\nSets iteration count and final scaling value to a DescentTracker.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Iteration-Data","page":"Internal","title":"Iteration Data","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"iterationdata.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.IterationData","page":"Internal","title":"PLaplace.IterationData","text":"mutable struct IterationData\n\nStores all data that changes during the iteration of the interior-point method. Especially computes gradient and hessian of the barrier function in each iteration.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.apply_descent!-Tuple{PLaplace.IterationData, PLaplace.StaticData}","page":"Internal","title":"PLaplace.apply_descent!","text":"apply_descent!(I::IterationData, S::StaticData; useBacktracking=true)\n\nPerforms backtracking with descent direction I.dx required for long and adaptive stepsizes\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.assemble!-Tuple{PLaplace.IterationData, PLaplace.StaticData}","page":"Internal","title":"PLaplace.assemble!","text":"assemble!(I::IterationData, S::StaticData)\n\nAssembles iteration values dependend on the present x and static data.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.set!-Tuple{PLaplace.IterationData, AbstractVector{Float64}, PLaplace.StaticData}","page":"Internal","title":"PLaplace.set!","text":"set!(I::IterationData, x::AbstractVector{Float64}, S::StaticData)\n\nSets iteration vector and reassembles dependencies, i.e. gradient and hessian.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.starnorm-Tuple{AbstractVector{Float64}, AbstractVector{Float64}}","page":"Internal","title":"PLaplace.starnorm","text":"starnorm(\n    v::AbstractVector{Float64},\n    w::AbstractVector{Float64}\n) -> Any\n\n\nSame as other starnorm(...), but with w = F(x)^-1 v precomputed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.starnorm-Tuple{AbstractVector{Float64}, PLaplace.IterationData, Function}","page":"Internal","title":"PLaplace.starnorm","text":"starnorm(\n    v::AbstractVector{Float64},\n    I::PLaplace.IterationData,\n    solveLS::Function\n) -> Any\n\n\nComputes norm induced by the barrier Vert v Vert^*_x = sqrtv F(x)^-1 v.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Log-Base","page":"Internal","title":"Log Base","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"logbase.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.cpad","page":"Internal","title":"PLaplace.cpad","text":"cpad(\n    s::Union{AbstractChar, AbstractString},\n    n::Integer\n) -> String\ncpad(\n    s::Union{AbstractChar, AbstractString},\n    n::Integer,\n    p::Union{AbstractChar, AbstractString}\n) -> String\n\n\nReimplemtation of deprecated function cpad based on current implementation of lpad and rpad.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#PLaplace.log_print_change_factorization-Tuple{Function}","page":"Internal","title":"PLaplace.log_print_change_factorization","text":"log_print_change_factorization(out::Function) -> Any\n\n\nPrints setup updated designed to fit the log to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_change_preconditioner-Tuple{Function}","page":"Internal","title":"PLaplace.log_print_change_preconditioner","text":"log_print_change_preconditioner(out::Function) -> Any\n\n\nPrints setup updated designed to fit the log to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_defaultdata-Tuple{Function, Mesh, Float64, Float64, String}","page":"Internal","title":"PLaplace.log_print_defaultdata","text":"log_print_defaultdata(\n    out::Function,\n    mesh::Mesh,\n    eps::Float64,\n    p::Float64,\n    stepsize::String\n) -> Any\n\n\nPrints problem data that had to be specified for the algorithm to the given output. \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_header-Tuple{Function}","page":"Internal","title":"PLaplace.log_print_header","text":"log_print_header(out::Function) -> Any\n\n\nPrints block header for the log to the given output. \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_iteration-Tuple{Function, Union{Missing, Int64}, Int64, String, Union{Missing, String}, Union{Missing, Int64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Int64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Float64}, Float64}","page":"Internal","title":"PLaplace.log_print_iteration","text":"log_print_iteration(\n    out::Function,\n    itr::Union{Missing, Int64},\n    offset::Int64,\n    prefix::String,\n    type::Union{Missing, String},\n    lastaccept::Union{Missing, Int64},\n    kappa::Union{Missing, Float64},\n    accnorm::Union{Missing, Float64},\n    searchitr::Union{Missing, Int64},\n    searchval::Union{Missing, Float64},\n    crit::Union{Missing, Float64},\n    t::Union{Missing, Float64},\n    bound::Float64\n) -> Any\n\n\nPrints one iteration for the log to the given output. In particular contains all relevant information and format parsing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_line-Tuple{Function}","page":"Internal","title":"PLaplace.log_print_line","text":"log_print_line(out::Function) -> Any\n\n\nPrints a vertical line of width corresponding to the log to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_setup-Tuple{Function, Int64}","page":"Internal","title":"PLaplace.log_print_setup","text":"log_print_setup(out::Function, stage::Int64) -> Any\n\n\nPrints setup updated designed to fit the log to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_spacing-Tuple{Function}","page":"Internal","title":"PLaplace.log_print_spacing","text":"log_print_spacing(out::Function) -> Any\n\n\nPrints spacing between log blocks to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_start-Tuple{Function}","page":"Internal","title":"PLaplace.log_print_start","text":"log_print_start(out::Function) -> Any\n\n\nPrints start of log to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_statistics-Tuple{Function, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Int64}, Union{Missing, Int64}, Float64, String}","page":"Internal","title":"PLaplace.log_print_statistics","text":"log_print_statistics(\n    out::Function,\n    tsetup::Union{Missing, Float64},\n    taux::Union{Missing, Float64},\n    tmain::Union{Missing, Float64},\n    Naux::Union{Missing, Int64},\n    Nmain::Union{Missing, Int64},\n    eps::Float64,\n    msg::String\n) -> Any\n\n\nPrints statistics of the full solution process to the given output. In particular contains required iterations and time as well as termination messages.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_text-Tuple{Function, String}","page":"Internal","title":"PLaplace.log_print_text","text":"log_print_text(out::Function, text::String) -> Any\n\n\nPrints a text shorter than the width of the log right aligned with frame to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_print_text_center-Tuple{Function, String}","page":"Internal","title":"PLaplace.log_print_text_center","text":"log_print_text_center(out::Function, text::String) -> Any\n\n\nPrints a text shorter than the width of the log center aligned with frame to the given output.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_write_header-Tuple{String}","page":"Internal","title":"PLaplace.log_write_header","text":"log_write_header(filename::String) -> Int64\n\n\nClears and writes a header for an stepwise log to the given file. \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_write_iteration-Tuple{String, Union{Missing, Int64}, Int64, String, Union{Missing, String}, Union{Missing, Int64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Int64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Float64}, Float64, Union{Missing, Float64}}","page":"Internal","title":"PLaplace.log_write_iteration","text":"log_write_iteration(\n    filename::String,\n    itr::Union{Missing, Int64},\n    offset::Int64,\n    prefix::String,\n    type::Union{Missing, String},\n    lastaccept::Union{Missing, Int64},\n    kappa::Union{Missing, Float64},\n    accnorm::Union{Missing, Float64},\n    searchitr::Union{Missing, Int64},\n    searchval::Union{Missing, Float64},\n    crit::Union{Missing, Float64},\n    t::Union{Missing, Float64},\n    bound::Float64,\n    condition::Union{Missing, Float64}\n) -> Int64\n\n\nWrites one iteration for an stepwise log to the given file. In particular contains all relevant information and format parsing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Log-Data","page":"Internal","title":"Log Data","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"logdata.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.LogData","page":"Internal","title":"PLaplace.LogData","text":"mutable struct LogData\n\nStructure to hold general information considering the log. In particular if the algorithm is verbose and if a log file is generated.\n\nFields\n\nisverbose::Bool: Flag indicating if output is verbose.\nout::Function: Output function is print() if verbose otherwise does nothing.\nlogobjective::Bool: Flag for logging the objective to file during the iteration.\ntrackcondition::Bool: Flag for logging the condition of the linear system to file during the iteration.\nfile::Union{Missing, String}: File name for writing log to file.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.LogData-Tuple{Bool, Union{Missing, String}, Bool}","page":"Internal","title":"PLaplace.LogData","text":"LogData(\n    verbose::Bool,\n    filename::Union{Missing, String},\n    logcondition::Bool\n) -> PLaplace.LogData\n\n\nConstructor for LogData with data.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.LogData-Tuple{}","page":"Internal","title":"PLaplace.LogData","text":"LogData() -> PLaplace.LogData\n\n\nConstructor for LogData with default values.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_change_factorization-Tuple{PLaplace.LogData}","page":"Internal","title":"PLaplace.log_change_factorization","text":"log_change_factorization(data::PLaplace.LogData) -> Any\n\n\nHandles change of factorization in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_change_preconditioner-Tuple{PLaplace.LogData}","page":"Internal","title":"PLaplace.log_change_preconditioner","text":"log_change_preconditioner(data::PLaplace.LogData) -> Any\n\n\nHandles change of preconditioner in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_defaultdata-Tuple{PLaplace.LogData, Mesh, Float64, Float64, String}","page":"Internal","title":"PLaplace.log_defaultdata","text":"log_defaultdata(\n    data::PLaplace.LogData,\n    mesh::Mesh,\n    eps::Float64,\n    p::Float64,\n    stepsize::String\n) -> Any\n\n\nHandles default data in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_footer-Tuple{PLaplace.LogData}","page":"Internal","title":"PLaplace.log_footer","text":"log_footer(data::PLaplace.LogData) -> Any\n\n\nHandles footer in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_header-Tuple{PLaplace.LogData}","page":"Internal","title":"PLaplace.log_header","text":"log_header(data::PLaplace.LogData) -> Any\n\n\nHandles header in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_iteration-Tuple{PLaplace.LogData, Union{Missing, Int64}, Int64, String, Union{Missing, String}, Union{Missing, Int64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Int64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Float64}, Float64}","page":"Internal","title":"PLaplace.log_iteration","text":"log_iteration(\n    data::PLaplace.LogData,\n    itr::Union{Missing, Int64},\n    offset::Int64,\n    prefix::String,\n    type::Union{Missing, String},\n    lastaccept::Union{Missing, Int64},\n    kappa::Union{Missing, Float64},\n    accnorm::Union{Missing, Float64},\n    searchitr::Union{Missing, Int64},\n    searchval::Union{Missing, Float64},\n    condition::Union{Missing, Float64},\n    crit::Union{Missing, Float64},\n    t::Union{Missing, Float64},\n    bound::Float64\n) -> Any\n\n\nHandles an iteration in the log for output stream and file generation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_line-Tuple{PLaplace.LogData}","page":"Internal","title":"PLaplace.log_line","text":"log_line(data::PLaplace.LogData) -> Any\n\n\nHandles horizontal line in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_setup-Tuple{PLaplace.LogData, Int64}","page":"Internal","title":"PLaplace.log_setup","text":"log_setup(data::PLaplace.LogData, stage::Int64) -> Any\n\n\nHandles setup in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_start-Tuple{PLaplace.LogData}","page":"Internal","title":"PLaplace.log_start","text":"log_start(data::PLaplace.LogData) -> Any\n\n\nHandles start block in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_statistics-Tuple{PLaplace.LogData, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Float64}, Union{Missing, Int64}, Union{Missing, Int64}, Float64, String}","page":"Internal","title":"PLaplace.log_statistics","text":"log_statistics(\n    data::PLaplace.LogData,\n    tsetup::Union{Missing, Float64},\n    taux::Union{Missing, Float64},\n    tmain::Union{Missing, Float64},\n    Naux::Union{Missing, Int64},\n    Nmain::Union{Missing, Int64},\n    eps::Float64,\n    msg::String\n) -> Any\n\n\nHandles statistics in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_text-Tuple{PLaplace.LogData, String}","page":"Internal","title":"PLaplace.log_text","text":"log_text(data::PLaplace.LogData, msg::String) -> Any\n\n\nHandles text line in the log for output stream. Is not relevant for file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Algorithm-Data","page":"Internal","title":"Algorithm Data","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"algorithmdata.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.AlgorithmData","page":"Internal","title":"PLaplace.AlgorithmData","text":"mutable struct AlgorithmData\n\nStructure to store statistics to the algorithm during the runtime. The information is supposed to be exported to PLaplaceData for external usage.\n\nFields\n\neps::Float64: Obtained accuracy.\nNaux::Union{Missing, Int64}: Required iterations for the auxilliary path-following.\nNmain::Union{Missing, Int64}: Required iterations for the main path-following.\ntsetup::Union{Missing, Float64}: Required time for the setup.\ntaux::Union{Missing, Float64}: Required time for the auxilliary path-following.\ntmain::Union{Missing, Float64}: Required time for the main path-following.\nsolution::Union{Missing, Vector{Float64}}: Solution vector if iteration converged.\nmsg::String: Notifications from the iteration.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#PLaplace.AlgorithmData-Tuple{}","page":"Internal","title":"PLaplace.AlgorithmData","text":"AlgorithmData() -> PLaplace.AlgorithmData\n\n\nConstructor for AlgorithmData with empty values.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.handle_accuracy!-Tuple{PLaplace.AlgorithmData, Float64}","page":"Internal","title":"PLaplace.handle_accuracy!","text":"handle_accuracy!(\n    data::PLaplace.AlgorithmData,\n    eps::Float64\n) -> Float64\n\n\nHandling the termination of a main path-following because of a singular system matrix.  In particular stores the resulting (reversly computed) obtained accuracy.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.handle_assembly!-Tuple{PLaplace.AlgorithmData, PLaplace.LogData, PLaplace.AssemblyTracker, String, Int64}","page":"Internal","title":"PLaplace.handle_assembly!","text":"handle_assembly!(\n    data::PLaplace.AlgorithmData,\n    log::PLaplace.LogData,\n    tracker::PLaplace.AssemblyTracker,\n    phase::String,\n    iteration::Int64\n) -> Any\n\n\nHandling the assembly of barrier terms.  In particular stores message if solver or preconditioner got changed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.handle_auxfail!-Tuple{PLaplace.AlgorithmData}","page":"Internal","title":"PLaplace.handle_auxfail!","text":"handle_auxfail!(data::PLaplace.AlgorithmData) -> String\n\n\nHandling the termination of the algorithm because the final update step in the auxilliary path-following failed because of a singular system matrix. \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.handle_kappavanish!-Tuple{PLaplace.AlgorithmData, String, Int64}","page":"Internal","title":"PLaplace.handle_kappavanish!","text":"handle_kappavanish!(\n    data::PLaplace.AlgorithmData,\n    phase::String,\n    iteration::Int64\n) -> String\n\n\nHandling the termination of the algorithm because the stepsize update parameter κ in a  path-following with adaptive stepping got numerically too small. Should theoretically not occur, so this usually indicates an infeasible problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.handle_maxiterations!-Tuple{PLaplace.AlgorithmData, String, Int64}","page":"Internal","title":"PLaplace.handle_maxiterations!","text":"handle_maxiterations!(\n    data::PLaplace.AlgorithmData,\n    phase::String,\n    iteration::Int64\n) -> String\n\n\nHandling the termination of the algorithm because the maximum number of iterations during a phase was reached.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.log_statistics-Tuple{PLaplace.AlgorithmData, PLaplace.LogData}","page":"Internal","title":"PLaplace.log_statistics","text":"log_statistics(\n    A::PLaplace.AlgorithmData,\n    L::PLaplace.LogData\n) -> Any\n\n\nWrapper for passing statistics to the log handling.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Path-Following","page":"Internal","title":"Path-Following","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"pathfollowing.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.pathfollowing_auxilliary_adaptive!-Tuple{PLaplace.IterationData, PLaplace.AlgorithmData, PLaplace.StaticData, PLaplace.LogData}","page":"Internal","title":"PLaplace.pathfollowing_auxilliary_adaptive!","text":"pathfollowing_auxilliary_adaptive!(\n    I::PLaplace.IterationData,\n    A::PLaplace.AlgorithmData,\n    S::PLaplace.StaticData,\n    L::PLaplace.LogData\n) -> Int64\n\n\nExecutes auxilliary path-following with adaptive stepsize.\n\nThe iteration is performed on the IterationData, which will later store the final iterate as well as all the corresponding barrier terms. The number of required iterations and potential messages will be stored in AlgorithmData. If LogData is verbose, data per iteration will be written to the output stream. Further, if a file is provided, the log will be also exported to that file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.pathfollowing_auxilliary_long!-Tuple{PLaplace.IterationData, PLaplace.AlgorithmData, PLaplace.StaticData, PLaplace.LogData}","page":"Internal","title":"PLaplace.pathfollowing_auxilliary_long!","text":"pathfollowing_auxilliary_long!(\n    I::PLaplace.IterationData,\n    A::PLaplace.AlgorithmData,\n    S::PLaplace.StaticData,\n    L::PLaplace.LogData\n) -> Int64\n\n\nExecutes auxilliary path-following with long stepsize.\n\nThe iteration is performed on the IterationData, which will later store the final iterate as well as all the corresponding barrier terms. The number of required iterations and potential messages will be stored in AlgorithmData. If LogData is verbose, data per iteration will be written to the output stream. Further, if a file is provided, the log will be also exported to that file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.pathfollowing_auxilliary_short!-Tuple{PLaplace.IterationData, PLaplace.AlgorithmData, PLaplace.StaticData, PLaplace.LogData}","page":"Internal","title":"PLaplace.pathfollowing_auxilliary_short!","text":"pathfollowing_auxilliary_short!(\n    I::PLaplace.IterationData,\n    A::PLaplace.AlgorithmData,\n    S::PLaplace.StaticData,\n    L::PLaplace.LogData\n) -> Int64\n\n\nExecutes auxilliary path-following with short stepsize.\n\nThe iteration is performed on the IterationData, which will later store the final iterate as well as all the corresponding barrier terms. The number of required iterations and potential messages will be stored in AlgorithmData. If LogData is verbose, data per iteration will be written to the output stream. Further, if a file is provided, the log will be also exported to that file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.pathfollowing_main_adaptive!-Tuple{PLaplace.IterationData, PLaplace.AlgorithmData, PLaplace.StaticData, PLaplace.LogData}","page":"Internal","title":"PLaplace.pathfollowing_main_adaptive!","text":"pathfollowing_main_adaptive!(\n    I::PLaplace.IterationData,\n    A::PLaplace.AlgorithmData,\n    S::PLaplace.StaticData,\n    L::PLaplace.LogData\n) -> Int64\n\n\nExecutes main path-following with adaptive stepsize.\n\nThe iteration is performed on the IterationData, which will later store the final result. If the iteration did not converge, the last iterate will still be provided as a result and  the obtained accuracy stored in AlgorithmData.  The number of required iterations and potential messages will be stored in AlgorithmData in any case. If LogData is verbose, data per iteration will be written to the output stream. Further, if a file is provided, the log will be also exported to that file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.pathfollowing_main_long!-Tuple{PLaplace.IterationData, PLaplace.AlgorithmData, PLaplace.StaticData, PLaplace.LogData}","page":"Internal","title":"PLaplace.pathfollowing_main_long!","text":"pathfollowing_main_long!(\n    I::PLaplace.IterationData,\n    A::PLaplace.AlgorithmData,\n    S::PLaplace.StaticData,\n    L::PLaplace.LogData\n) -> Int64\n\n\nExecutes main path-following with long stepsize.\n\nThe iteration is performed on the IterationData, which will later store the final result. If the iteration did not converge, the last iterate will still be provided as a result and  the obtained accuracy stored in AlgorithmData.  The number of required iterations and potential messages will be stored in AlgorithmData in any case. If LogData is verbose, data per iteration will be written to the output stream. Further, if a file is provided, the log will be also exported to that file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.pathfollowing_main_short!-Tuple{PLaplace.IterationData, PLaplace.AlgorithmData, PLaplace.StaticData, PLaplace.LogData}","page":"Internal","title":"PLaplace.pathfollowing_main_short!","text":"pathfollowing_main_short!(\n    I::PLaplace.IterationData,\n    A::PLaplace.AlgorithmData,\n    S::PLaplace.StaticData,\n    L::PLaplace.LogData\n) -> Int64\n\n\nExecutes main path-following with short stepsize.\n\nThe iteration is performed on the IterationData, which will later store the final result. If the iteration did not converge, the last iterate will still be provided as a result and  the obtained accuracy stored in AlgorithmData.  The number of required iterations and potential messages will be stored in AlgorithmData in any case. If LogData is verbose, data per iteration will be written to the output stream. Further, if a file is provided, the log will be also exported to that file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.select_pathfollowing-Tuple{Stepsize}","page":"Internal","title":"PLaplace.select_pathfollowing","text":"select_pathfollowing(stepsize::Stepsize) -> Tuple{Function, Function}\n\nReturns functions for auxilliary and main pathfollowing dependend on the stepsize.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#p-Laplace-Data","page":"Internal","title":"p-Laplace Data","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"plaplacedata.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.add_algorithmdata!-Tuple{PLaplaceData, PLaplace.AlgorithmData}","page":"Internal","title":"PLaplace.add_algorithmdata!","text":"add_algorithmdata!(\n    data::PLaplaceData,\n    algorithm::PLaplace.AlgorithmData\n) -> Union{Nothing, Vector{Float64}}\n\n\nAdds required values from the iteration data to the output data, especially the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.add_staticdata!-Tuple{PLaplaceData, PLaplace.StaticData}","page":"Internal","title":"PLaplace.add_staticdata!","text":"add_staticdata!(\n    data::PLaplaceData,\n    S::PLaplace.StaticData\n) -> Set{Int64}\n\n\nAdds required values from the static data to the output data. In particular the prolonged boundary and which nodes will not be fixed during the computation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.assemble_result!-Tuple{PLaplaceData}","page":"Internal","title":"PLaplace.assemble_result!","text":"assemble_result!(\n    data::PLaplaceData\n) -> Union{Nothing, Vector{Float64}}\n\n\nAssembles combined result vector v = u + g for truncated u vector u_I.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Algorithm","page":"Internal","title":"Algorithm","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"algorithm.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.check_parameters-Tuple{Float64, Int64, Float64, Float64, Array{Int64, N} where N, Array{Float64, N} where N}","page":"Internal","title":"PLaplace.check_parameters","text":"check_parameters(\n    p::Float64,\n    qdim::Int64,\n    eps::Float64,\n    kappa::Float64,\n    kappa_updates::Array{Int64, N} where N,\n    kappa_powers::Array{Float64, N} where N\n)\n\n\nThrows error if given parameters are not in the designated range.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Problem","page":"Internal","title":"Problem","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [PLaplace]\nPages = [\"problem.jl\"]\nPublic = false","category":"page"},{"location":"lib/internal/#PLaplace.compute_plaplace_term-Tuple{AbstractVector{Float64}, Float64, Mesh, Int64}","page":"Internal","title":"PLaplace.compute_plaplace_term","text":"compute_plaplace_term(\n    u::AbstractVector{Float64},\n    p::Float64,\n    mesh::Mesh,\n    qdim::Int64\n) -> Float64\n\n\nComputes value of characteristic derivative term in p-Laplace functional evaluated at u.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PLaplace.compute_sources-Tuple{AbstractVector{Float64}, Mesh, Union{Missing, Set{Int64}, Set{Boundary}}, Union{Missing, Function, AbstractVector{Float64}}, Union{Missing, Function, AbstractVector{Float64}}, Int64}","page":"Internal","title":"PLaplace.compute_sources","text":"compute_sources(\n    u::AbstractVector{Float64},\n    mesh::Mesh,\n    neumann_boundary::Union{Missing, Set{Int64}, Set{Boundary}},\n    h::Union{Missing, Function, AbstractVector{Float64}},\n    f::Union{Missing, Function, AbstractVector{Float64}},\n    qdim::Int64\n) -> Float64\n\n\nComputes value of the required boundary and volume source terms for the p-Laplace functional evaluated at u.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Index","page":"Internal","title":"Index","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Pages = [\"internal.md\"]\nOrder = [:type, :function]","category":"page"}]
}
